package sourcegraph

import (
	"errors"
	"fmt"

	"strconv"
	"strings"
)

func (u *User) Spec() UserSpec {
	return UserSpec{Login: u.Login, UID: u.UID}
}

// GitHubLogin returns the user's Login. They are the same for now, but callers
// that intend to get the GitHub login should call GitHubLogin() so that we can
// decouple the logins in the future if needed.
func (u *User) GitHubLogin() string {
	if u.GitHubID == 0 {
		return ""
	}
	return u.Login
}

// IsOrganization is whether this user represents a GitHub organization
// (which are treated as a subclass of User in GitHub's data model).
func (u *User) IsOrganization() bool { return u.Type == "Organization" }

// AvatarURLOfSize returns the URL to an avatar for the user with the
// given width (in pixels).
func (u *User) AvatarURLOfSize(width int) string {
	return avatarURLOfSize(u.AvatarURL, width)
}

func avatarURLOfSize(avatarURL string, width int) string {
	return avatarURL + fmt.Sprintf("&s=%d", width)
}

// CanOwnRepositories is whether the user is capable of owning repositories
// (e.g., GitHub users can own GitHub repositories).
func (u *User) CanOwnRepositories() bool {
	return u.GitHubLogin() != ""
}

// CanAttributeCodeTo is whether this user can commit code. It is false for
// organizations and true for both users and transient users.
func (u *User) CanAttributeCodeTo() bool {
	return !u.IsOrganization()
}

// Person returns an equivalent Person.
func (u *User) Person() *Person {
	return &Person{
		PersonSpec: PersonSpec{UID: u.UID, Login: u.Login},
		FullName:   u.Name,
		AvatarURL:  u.AvatarURL,
	}
}

// PathComponent returns the URL path component that specifies the user.
func (s *UserSpec) PathComponent() string {
	if s.Login != "" {
		return s.Login
	}
	if s.UID > 0 {
		return "$" + strconv.Itoa(int(s.UID))
	}
	panic("empty UserSpec")
}

func (s *UserSpec) RouteVars() map[string]string {
	return map[string]string{"UserSpec": s.PathComponent()}
}

// ParseUserSpec parses a string generated by (*UserSpec).String() and
// returns the equivalent UserSpec struct.
func ParseUserSpec(pathComponent string) (UserSpec, error) {
	if strings.Contains(pathComponent, "@") {
		return UserSpec{}, fmt.Errorf("UserSpec %q must not contain '@'")
	}
	if strings.HasPrefix(pathComponent, "$") {
		uid, err := strconv.Atoi(pathComponent[1:])
		return UserSpec{UID: int32(uid)}, err
	}
	return UserSpec{Login: pathComponent}, nil
}

// ErrUserNotExist is an error indicating that no such user exists.
var ErrUserNotExist = errors.New("user does not exist")

// ErrUserRenamed is an error type that indicates that a user account was renamed
// from OldLogin to NewLogin.
type ErrUserRenamed struct {
	// OldLogin is the previous login name.
	OldLogin string

	// NewLogin is what the old login was renamed to.
	NewLogin string
}

func (e ErrUserRenamed) Error() string {
	return fmt.Sprintf("login %q was renamed to %q; use the new name", e.OldLogin, e.NewLogin)
}
