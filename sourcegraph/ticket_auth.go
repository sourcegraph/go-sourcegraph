package sourcegraph

import (
	"encoding/json"
	"net/http"
	"strings"

	"golang.org/x/net/context"
	"google.golang.org/grpc/metadata"
)

// TicketAuthScheme is the HTTP authorization scheme used for tickets
// in HTTP request or response Authorization headers.
const TicketAuthScheme = "Sourcegraph-Ticket "

// A TicketAuth is an HTTP transport and gRPC credential provider that
// adds auth tickets to requests.
//
// For HTTP/1, it adds a "Authorization: Sourcegraph-Ticket xxx..."
// header to each request for each of its SignedTicketStrings. It can
// be used to perform HTTP requests with specific permissions on a
// resource. The signed ticket strings must be generated by the
// Sourcegraph server.
//
// Currently only internal (non-public) API endpoints return or
// require tickets.
type TicketAuth struct {
	// SignedTicketStrings are the signed ticket strings to send with
	// each HTTP request. They must not contain the
	// "Sourcegraph-Ticket " prefix (the auth scheme).
	SignedTicketStrings []string

	// Transport is the underlying HTTP/1 transport to use. If nil,
	// http.DefaultTransport is used.
	Transport http.RoundTripper
}

func (t TicketAuth) NewTransport(underlying http.RoundTripper) http.RoundTripper {
	// Non-pointer method, so we don't modify.
	t.Transport = underlying
	return t
}

// RoundTrip implements http.RoundTripper.
func (t TicketAuth) RoundTrip(req *http.Request) (*http.Response, error) {
	var transport http.RoundTripper
	if t.Transport != nil {
		transport = t.Transport
	} else {
		transport = http.DefaultTransport
	}

	if len(t.SignedTicketStrings) > 0 {
		// To set extra headers, we must make a copy of the Request so
		// that we don't modify the Request we were given. This is
		// required by the specification of http.RoundTripper.
		req = cloneRequest(req)
		for _, tstr := range t.SignedTicketStrings {
			req.Header.Add("authorization", TicketAuthScheme+tstr)
		}
	}

	// Make the HTTP request.
	return transport.RoundTrip(req)
}

// GetRequestMetadata implements gRPC's credentials.Credentials
// interface.
func (t *TicketAuth) GetRequestMetadata(ctx context.Context) (map[string]string, error) {
	b, err := json.Marshal(t.SignedTicketStrings)
	if err != nil {
		return nil, err
	}
	return map[string]string{TicketAuthID: string(b)}, nil
}

// TicketAuthID is the gRPC metadata key and the HTTP Basic username
// that indicates ticket auth is provided. The value or password
// contains the ticket string.
const TicketAuthID = "x-sourcegraph-ticket"

// ReadTicketAuth gets the signed ticket strings from the subset
// of the HTTP headers that are of the form "Authorization:
// Sourcegraph-Ticket xxx...". The returned strings do not include the
// "Sourcegraph-Ticket " prefix.
//
// The returned strings can be used in TicketAuth's
// SignedTicketStrings field to authenticate outgoing requests using
// these tickets.
//
// Exactly one of hdr and md must be set. The func takes both
// arguments to avoid the confusion of having one func for reading
// HTTP/1 credentials and another func for reading gRPC credentials.
func ReadTicketAuth(hdr http.Header, md metadata.MD) ([]string, error) {
	switch {
	case hdr != nil && md != nil:
		panic("exactly one of hdr and md must be set")

	case hdr != nil:
		var tstrs []string
		for _, authHdr := range hdr[http.CanonicalHeaderKey("authorization")] {
			if !strings.HasPrefix(authHdr, TicketAuthScheme) {
				continue
			}
			tstrs = append(tstrs, strings.TrimPrefix(authHdr, TicketAuthScheme))
		}

		// Also check HTTP Basic auth for credentials with username
		// "x-sourcegraph-ticket" and password being a single ticket.
		hasBasicTicket, username, ticketStr, err := ReadPasswordAuth(hdr, nil)
		if err == nil && hasBasicTicket && username == TicketAuthID {
			tstrs = append(tstrs, ticketStr)
		}

		return tstrs, nil

	case md != nil:
		v, ok := md[TicketAuthID]
		if !ok {
			return nil, nil
		}
		var tstrs []string
		if err := json.Unmarshal([]byte(v), &tstrs); err != nil {
			return nil, err
		}
		return tstrs, nil

	}
	return nil, nil
}
