// Code generated by protoc-gen-gogo.
// source: sourcegraph.proto
// DO NOT EDIT!

/*
Package sourcegraph is a generated protocol buffer package.

It is generated from these files:
	sourcegraph.proto

It has these top-level messages:
	Badge
	CombinedStatus
	Counter
	ListOptions
	ListResponse
	Discussion
	DiscussionComment
	Changeset
	ChangesetReview
	ChangesetEvent
	InlineComment
	Readme
	GitHubRepo
	RepoConfig
	Repo
	BadgeList
	CounterList
	RepoBadgesCountHitsOp
	RepoBadgesCountHitsResult
	RepoListOptions
	RepoPermissions
	RepoRevSpec
	RepoSpec
	RepoStatus
	RepoStatusesCreateOp
	RepoList
	ReposCreateOp
	ReposListCommitsOp
	RepoListCommitsOptions
	CommitList
	ReposListBranchesOp
	RepoListBranchesOptions
	BranchList
	ReposListTagsOp
	ReposListCommittersOp
	RepoListCommittersOptions
	CommitterList
	ChangesetCreateOp
	ChangesetCreateReviewOp
	ChangesetListReviewsOp
	ChangesetSpec
	ChangesetUpdateOp
	DiscussionSpec
	DiscussionListOp
	DiscussionCommentCreateOp
	DiscussionRatingUpdateOp
	RepoListTagsOptions
	TagList
	MirroredRepoSSHKeysCreateOp
	SSHPrivateKey
	Build
	BuildConfig
	BuildCreateOptions
	BuildGetLogOptions
	BuildListOptions
	ChangesetListOp
	BuildSpec
	BuildTask
	BuildTaskListOptions
	BuildUpdate
	BuildsGetRepoBuildInfoOptions
	BuildsGetRepoBuildInfoOp
	BuildList
	BuildsCreateOp
	BuildsUpdateOp
	BuildsListBuildTasksOp
	BuildTaskList
	ChangesetReviewList
	ChangesetList
	ChangesetEventList
	DiscussionList
	BuildsCreateTasksOp
	BuildsUpdateTaskOp
	BuildsGetLogOp
	BuildsGetTaskLogOp
	BuildsDequeueNextOp
	EmailAddr
	LogEntries
	Org
	OrgListMembersOptions
	OrgSpec
	OrgsListMembersOp
	UserList
	Person
	PersonSpec
	RepoBuildInfo
	TaskSpec
	TaskUpdate
	User
	UserSpec
	UsersListOptions
	OrgsListOp
	EmailAddrList
	OrgList
	PasswordResetToken
	NewPassword
	NewAccount
	AuthorizationCodeRequest
	AuthorizationCode
	LoginCredentials
	BearerJWT
	AccessTokenRequest
	AccessTokenResponse
	AuthInfo
	AuthorshipInfo
	Completions
	Def
	DefAuthor
	DefAuthorship
	DefClient
	DefDelta
	DefGetOptions
	DefListAuthorsOptions
	DefListClientsOptions
	DefListExamplesOptions
	DefListOptions
	DefListRefsOptions
	DefSpec
	DefsGetOp
	DefList
	DefsListRefsOp
	RefList
	DefsListExamplesOp
	ExampleList
	DefsListAuthorsOp
	DefsListClientsOp
	Delta
	DeltaAffectedPerson
	DeltaDefs
	FileDiff
	Hunk
	DeltaFiles
	DeltaFilter
	DeltaListAffectedAuthorsOptions
	DeltaListAffectedClientsOptions
	DeltaListDefsOptions
	DeltaListFilesOptions
	DeltaListUnitsOptions
	DeltaSpec
	DeltasListUnitsOp
	UnitDeltaList
	DeltasListDefsOp
	DeltasListFilesOp
	DeltasListAffectedAuthorsOp
	DeltaAffectedPersonList
	DeltasListAffectedClientsOp
	Example
	FormatResult
	MarkdownData
	MarkdownOpt
	MarkdownRequestBody
	MarkdownRenderOp
	Ref
	RepoTreeGetOptions
	RepoTreeSearchOptions
	RepoTreeSearchResult
	RepoTreeGetOp
	RepoTreeSearchOp
	VCSSearchResultList
	SearchOptions
	SearchResults
	SuggestionList
	SourceCode
	SourceCodeLine
	SourceCodeToken
	TreeEntry
	TreeEntrySpec
	UnitDelta
	UnitListOptions
	UnitSpec
	RepoSourceUnitList
	DefAuthorList
	DefClientList
	Checklist
	FileToken
	Plan
	RawQuery
	RepoToken
	ResolvedQuery
	RevToken
	Suggestion
	UnitToken
	UserToken
	TokenError
	PBToken
	ServerStatus
	ServerConfig
	RegisteredClient
	RegisteredClientSpec
	RegisteredClientCredentials
	RegisteredClientListOptions
	RegisteredClientList
	MetricsSnapshot
*/
package sourcegraph

import proto "github.com/gogo/protobuf/proto"

// discarding unused import gogoproto "github.com/gogo/protobuf/gogoproto/gogo.pb"
import diff "sourcegraph.com/sourcegraph/go-diff/diff"
import vcs "sourcegraph.com/sourcegraph/go-vcs/vcs"
import graph "sourcegraph.com/sourcegraph/srclib/graph"
import graph1 "sourcegraph.com/sourcegraph/srclib/graph"
import unit "sourcegraph.com/sourcegraph/srclib/unit"
import vcsclient "sourcegraph.com/sourcegraph/vcsstore/vcsclient"
import pbtypes "sourcegraph.com/sqs/pbtypes"
import pbtypes1 "sourcegraph.com/sqs/pbtypes"
import pbtypes2 "sourcegraph.com/sqs/pbtypes"

// discarding unused import google_api1 "google/api/annotations.pb"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal

// RegisteredClientType is the set of kinds of clients.
type RegisteredClientType int32

const (
	// Any is any type of API client. It should only be used when
	// listing and not actually set on a RegisteredClient object.
	RegisteredClientType_Any RegisteredClientType = 0
	// Other is all other kinds of clients that are not
	// SourcegraphServers.
	RegisteredClientType_Other RegisteredClientType = 1
	// SourcegraphServer indicates this client is a Sourcegraph server
	// instance.
	RegisteredClientType_SourcegraphServer RegisteredClientType = 2
)

var RegisteredClientType_name = map[int32]string{
	0: "Any",
	1: "Other",
	2: "SourcegraphServer",
}
var RegisteredClientType_value = map[string]int32{
	"Any":               0,
	"Other":             1,
	"SourcegraphServer": 2,
}

func (x RegisteredClientType) String() string {
	return proto.EnumName(RegisteredClientType_name, int32(x))
}

// TelemetryType is the format MetricsSnapshot.TelemetryData is encoded in
type TelemetryType int32

const (
	// PrometheusDelimited0dot0dot4 indicates the metrics can be decoded using
	// Prometheus 0.0.4 delimited protobuf format
	TelemetryType_PrometheusDelimited0dot0dot4 TelemetryType = 0
)

var TelemetryType_name = map[int32]string{
	0: "PrometheusDelimited0dot0dot4",
}
var TelemetryType_value = map[string]int32{
	"PrometheusDelimited0dot0dot4": 0,
}

func (x TelemetryType) String() string {
	return proto.EnumName(TelemetryType_name, int32(x))
}

type Badge struct {
	Name              string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Description       string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	ImageURL          string `protobuf:"bytes,3,opt,name=image_url,proto3" json:"image_url,omitempty"`
	UncountedImageURL string `protobuf:"bytes,4,opt,name=uncounted_image_url,proto3" json:"uncounted_image_url,omitempty"`
	Markdown          string `protobuf:"bytes,5,opt,name=markdown,proto3" json:"markdown,omitempty"`
}

func (m *Badge) Reset()         { *m = Badge{} }
func (m *Badge) String() string { return proto.CompactTextString(m) }
func (*Badge) ProtoMessage()    {}

// CombinedStatus is the combined status (i.e., incorporating statuses from all
// contexts) of the repository at a specific rev.
type CombinedStatus struct {
	// Rev is the revision that this status describes. It is set mutually exclusive with CommitID.
	Rev string `protobuf:"bytes,4,opt,name=rev,proto3" json:"rev,omitempty"`
	// CommitID is the full commit ID of the commit this status describes. It is set mutually exclusively with Rev.
	CommitID string `protobuf:"bytes,1,opt,name=commit_id,proto3" json:"commit_id,omitempty"`
	// State is the combined status of the repository. Possible values are: failure,
	// pending, or success.
	State string `protobuf:"bytes,2,opt,name=state,proto3" json:"state,omitempty"`
	// Statuses are the statuses for each context.
	Statuses []*RepoStatus `protobuf:"bytes,3,rep,name=statuses" json:"statuses,omitempty"`
}

func (m *CombinedStatus) Reset()         { *m = CombinedStatus{} }
func (m *CombinedStatus) String() string { return proto.CompactTextString(m) }
func (*CombinedStatus) ProtoMessage()    {}

type Counter struct {
	Name              string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Description       string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	ImageURL          string `protobuf:"bytes,3,opt,name=image_url,proto3" json:"image_url,omitempty"`
	UncountedImageURL string `protobuf:"bytes,4,opt,name=uncounted_image_url,proto3" json:"uncounted_image_url,omitempty"`
	Markdown          string `protobuf:"bytes,5,opt,name=markdown,proto3" json:"markdown,omitempty"`
}

func (m *Counter) Reset()         { *m = Counter{} }
func (m *Counter) String() string { return proto.CompactTextString(m) }
func (*Counter) ProtoMessage()    {}

// ListOptions specifies general pagination options for fetching a list of results.
type ListOptions struct {
	PerPage int32 `protobuf:"varint,1,opt,name=per_page,proto3" json:"per_page,omitempty" url:",omitempty"`
	Page    int32 `protobuf:"varint,2,opt,name=page,proto3" json:"page,omitempty" url:",omitempty"`
}

func (m *ListOptions) Reset()         { *m = ListOptions{} }
func (m *ListOptions) String() string { return proto.CompactTextString(m) }
func (*ListOptions) ProtoMessage()    {}

// ListResponse specifies general pagination response when fetching a list of results.
type ListResponse struct {
	// HasMore is true if there are more entries available after the returned page.
	HasMore bool `protobuf:"varint,1,opt,name=has_more,proto3" json:"has_more,omitempty" url:",omitempty"`
}

func (m *ListResponse) Reset()         { *m = ListResponse{} }
func (m *ListResponse) String() string { return proto.CompactTextString(m) }
func (*ListResponse) ProtoMessage()    {}

// Discussion stores information about a discussion
type Discussion struct {
	// ID is the unique identifier for this discussion, relative to the repository
	// that contains it.
	ID int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Title holds a summary about this discussion.
	Title string `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	// Description holds the description for this discussion.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// Author is the user that initiated this discussion.
	Author UserSpec `protobuf:"bytes,4,opt,name=author" json:"author"`
	// DefKey is the unit the discussion is about. Note that a DefKey
	// contains a commit component, but we track Discussions across
	// commits. So all lookups normalize out the commit component, but the
	// commit component records the commit at the time the Discussion was
	// created.
	DefKey graph.DefKey `protobuf:"bytes,5,opt,name=def_key" json:"def_key"`
	// Ratings contains a list of users who have "starred" the discussion
	Ratings []*UserSpec `protobuf:"bytes,6,rep,name=ratings" json:"ratings,omitempty"`
	// Comments contains comments by users in the discussion
	Comments []*DiscussionComment `protobuf:"bytes,7,rep,name=comments" json:"comments,omitempty"`
	// CreatedAt holds the creation time of this changeset.
	CreatedAt *pbtypes.Timestamp `protobuf:"bytes,8,opt,name=created_at" json:"created_at,omitempty"`
}

func (m *Discussion) Reset()         { *m = Discussion{} }
func (m *Discussion) String() string { return proto.CompactTextString(m) }
func (*Discussion) ProtoMessage()    {}

// DiscussionComment contains information about a single comment by a user.
type DiscussionComment struct {
	// ID holds the unique identifier (with reference to the Discussion) of the
	// comment.
	ID int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Body holds the text description of the comment.
	Body string `protobuf:"bytes,2,opt,name=body,proto3" json:"body,omitempty"`
	// Author is the spec of the user that submitted this comment.
	Author UserSpec `protobuf:"bytes,3,opt,name=author" json:"author"`
	// DefKey is the unit the discussion is about. Note this will be the
	// same as the Discussion's DefKey, except the commit component will
	// be the commit the user submitted on.
	DefKey graph.DefKey `protobuf:"bytes,5,opt,name=def_key" json:"def_key"`
	// CreatedAt is the date at which this comment was submitted.
	CreatedAt *pbtypes.Timestamp `protobuf:"bytes,6,opt,name=created_at" json:"created_at,omitempty"`
}

func (m *DiscussionComment) Reset()         { *m = DiscussionComment{} }
func (m *DiscussionComment) String() string { return proto.CompactTextString(m) }
func (*DiscussionComment) ProtoMessage()    {}

// Changeset stores information about a changeset.
type Changeset struct {
	// ID is the unique identifier for this changeset, relative to the repository
	// that contains it.
	ID int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Title holds a summary about this changeset.
	Title string `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	// Description holds the description for this changeset.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// Author is the user that initiated this changeset.
	Author UserSpec `protobuf:"bytes,4,opt,name=author" json:"author"`
	// DeltaSpec contains information about the base and head spec for this
	// changeset.
	DeltaSpec *DeltaSpec `protobuf:"bytes,5,opt,name=delta_spec" json:"delta_spec,omitempty"`
	// Merged specifies whether this changeset was merged.
	Merged bool `protobuf:"varint,6,opt,name=merged,proto3" json:"merged,omitempty"`
	// CreatedAt holds the creation time of this changeset.
	CreatedAt *pbtypes.Timestamp `protobuf:"bytes,7,opt,name=created_at" json:"created_at,omitempty"`
	// ClosedAt holds the time when this changeset was closed or merged.
	ClosedAt *pbtypes.Timestamp `protobuf:"bytes,8,opt,name=closed_at" json:"closed_at,omitempty"`
}

func (m *Changeset) Reset()         { *m = Changeset{} }
func (m *Changeset) String() string { return proto.CompactTextString(m) }
func (*Changeset) ProtoMessage()    {}

// ChangesetReview contains information about a review submitted on a changeset.
type ChangesetReview struct {
	// ID holds the unique identifier (with reference to the changeset) of the
	// review.
	ID int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// Body holds the text description of the review.
	Body string `protobuf:"bytes,2,opt,name=body,proto3" json:"body,omitempty"`
	// Author is the spec of the user that submitted this review.
	Author UserSpec `protobuf:"bytes,3,opt,name=author" json:"author"`
	// CreatedAt is the date at which this review was submitted.
	CreatedAt *pbtypes.Timestamp `protobuf:"bytes,4,opt,name=created_at" json:"created_at,omitempty"`
	// EditedAt is the last time at which this review was edited. If the review
	// has never been edited, this value will be nil.
	EditedAt *pbtypes.Timestamp `protobuf:"bytes,5,opt,name=edited_at" json:"edited_at,omitempty"`
	// Comments holds any inline comments that were submitted along with this
	// review.
	Comments []*InlineComment `protobuf:"bytes,6,rep,name=comments" json:"comments,omitempty"`
	// Deleted specifies whether this review has been removed.
	Deleted bool `protobuf:"varint,7,opt,name=deleted,proto3" json:"deleted,omitempty"`
}

func (m *ChangesetReview) Reset()         { *m = ChangesetReview{} }
func (m *ChangesetReview) String() string { return proto.CompactTextString(m) }
func (*ChangesetReview) ProtoMessage()    {}

// ChangesetEvent holds information about an update that occurred on the
// properties of a Changeset.
type ChangesetEvent struct {
	// Before holds the changeset as it was before the event.
	Before *Changeset `protobuf:"bytes,2,opt,name=before" json:"before,omitempty"`
	// After holds the changeset as it became after the event.
	After *Changeset `protobuf:"bytes,3,opt,name=after" json:"after,omitempty"`
	// Op holds the update operation that changed the state.
	Op *ChangesetUpdateOp `protobuf:"bytes,4,opt,name=op" json:"op,omitempty"`
	// CreatedAt is the date at which the event was created.
	CreatedAt *pbtypes.Timestamp `protobuf:"bytes,5,opt,name=created_at" json:"created_at,omitempty"`
}

func (m *ChangesetEvent) Reset()         { *m = ChangesetEvent{} }
func (m *ChangesetEvent) String() string { return proto.CompactTextString(m) }
func (*ChangesetEvent) ProtoMessage()    {}

// InlineComment represents a comment made on a line of code. It is uniquely identified
// via Filename + LineNumber + CommitID. In a Changeset, the CommitID might vary
// within the same file based on whether the comment was made on the lines that
// match the pre-index SHA-1 or the lines that match the post-index SHA-1. Pre
// and post index values may differ from Base and Head of the diff.
// For more information on indexes see http://git-scm.com/docs/git-diff-index
type InlineComment struct {
	// Filename is the name of the file where this comment was made.
	Filename string `protobuf:"bytes,1,opt,name=filename,proto3" json:"filename,omitempty"`
	// LineNumber is the line number relative to the beginning of the file in
	// the specified commit.
	LineNumber int32 `protobuf:"varint,2,opt,name=line_number,proto3" json:"line_number,omitempty"`
	// CommitID is the SHA-1 for the post-image of this file, where the comment
	// was placed. The post-image can be deduced from the file entry in the diff
	// that it belong by extracting it's extended header's index entry.
	CommitID string `protobuf:"bytes,3,opt,name=commit_id,proto3" json:"commit_id,omitempty"`
	// Author is the user that initiated this changeset.
	Author UserSpec `protobuf:"bytes,4,opt,name=author" json:"author"`
	// Body holds the body of this comment.
	Body string `protobuf:"bytes,5,opt,name=body,proto3" json:"body,omitempty"`
	// CreatedAt holds the creation date of this comment.
	CreatedAt *pbtypes.Timestamp `protobuf:"bytes,6,opt,name=created_at" json:"created_at,omitempty"`
	// EditedAt holds the time when this comment was last edited. If no edits occurred,
	// it will be null.
	EditedAt *pbtypes.Timestamp `protobuf:"bytes,7,opt,name=edited_at" json:"edited_at,omitempty"`
	// Deleted indicates whether the comment has been deleted.
	Deleted bool `protobuf:"varint,8,opt,name=deleted,proto3" json:"deleted,omitempty"`
}

func (m *InlineComment) Reset()         { *m = InlineComment{} }
func (m *InlineComment) String() string { return proto.CompactTextString(m) }
func (*InlineComment) ProtoMessage()    {}

// A Readme represents a formatted "README"-type file in a repository.
type Readme struct {
	// Path is the relative path of this readme file from the repository root.
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	// HTML is the formatted HTML of this readme.
	HTML string `protobuf:"bytes,2,opt,name=html,proto3" json:"html,omitempty"`
}

func (m *Readme) Reset()         { *m = Readme{} }
func (m *Readme) String() string { return proto.CompactTextString(m) }
func (*Readme) ProtoMessage()    {}

// GitHubRepo holds additional metadata about GitHub repos.
type GitHubRepo struct {
	Stars int32 `protobuf:"varint,1,opt,name=stars,proto3" json:"stars,omitempty"`
}

func (m *GitHubRepo) Reset()         { *m = GitHubRepo{} }
func (m *GitHubRepo) String() string { return proto.CompactTextString(m) }
func (*GitHubRepo) ProtoMessage()    {}

// RepoConfig describes a repository's config. This config is
// Sourcegraph-specific and is persisted locally.
//
// Note: See the RepoOrigins doc for more information on the split
// between Sourcegraph-specific data and origin-specific data.
type RepoConfig struct {
	// Enabled is whether this repository has been enabled for use on
	// Sourcegraph by a repository owner or a site admin.
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled,omitempty"`
	// LastAdminUID is the UID of the last repo admin user to modify
	// this repo's settings (for mirrored repos only). When
	// Sourcegraph needs to perform actions on mirrored GitHub repos
	// that require OAuth authorization outside of an authorized API
	// request (e.g., during builds or asynchronous operations), it
	// consults the repo's LastAdminUID to determine whose identity it
	// should assume to perform the operation.
	//
	// If the LastAdminUID refers to a user who no longer has
	// permissions to perform the action, GitHub will refuse to
	// perform the operation. In that case, another admin of the
	// repository needs to update the settings so that she will become
	// the new LastAdminUID.
	LastAdminUID int32 `protobuf:"varint,2,opt,name=last_admin_uid,proto3" json:"last_admin_uid,omitempty"`
}

func (m *RepoConfig) Reset()         { *m = RepoConfig{} }
func (m *RepoConfig) String() string { return proto.CompactTextString(m) }
func (*RepoConfig) ProtoMessage()    {}

// Repo represents a source code repository.
type Repo struct {
	// URI is a normalized identifier for this repository based on its primary clone
	// URL. E.g., "github.com/user/repo".
	URI string `protobuf:"bytes,1,opt,name=uri,proto3" json:"uri,omitempty"`
	// Origin is populated for repos fetched via federation or
	// discovery. It is the hostname of the host that owns the repo.
	Origin string `protobuf:"bytes,21,opt,name=origin,proto3" json:"origin,omitempty"`
	// Name is the base name (the final path component) of the repository, typically
	// the name of the directory that the repository would be cloned into. (For
	// example, for git://example.com/foo.git, the name is "foo".)
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Description is a brief description of the repository.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// VCS is the short name of the VCS system that this repository uses: "git" or
	// "hg".
	VCS string `protobuf:"bytes,4,opt,name=vcs,proto3" json:"vcs,omitempty"`
	// HTTPCloneURL is the HTTPS clone URL of the repository (or the HTTP clone URL, if
	// no HTTPS clone URL is available).
	HTTPCloneURL string `protobuf:"bytes,5,opt,name=http_clone_url,proto3" json:"http_clone_url,omitempty"`
	// SSHCloneURL is the SSH clone URL if the repository, if any.
	SSHCloneURL string `protobuf:"bytes,6,opt,name=ssh_clone_url,proto3" json:"ssh_clone_url,omitempty"`
	// HomepageURL is the URL to the repository's homepage, if any.
	HomepageURL string `protobuf:"bytes,7,opt,name=homepage_url,proto3" json:"homepage_url,omitempty"`
	// DefaultBranch is the default VCS branch used (typically "master" for git
	// repositories and "default" for hg repositories).
	DefaultBranch string `protobuf:"bytes,8,opt,name=default_branch,proto3" json:"default_branch,omitempty"`
	// Language is the primary programming language used in this repository.
	Language string `protobuf:"bytes,9,opt,name=language,proto3" json:"language,omitempty"`
	// Blocked is whether this repo has been blocked by an admin (and
	// will not be returned via the external API).
	Blocked bool `protobuf:"varint,10,opt,name=blocked,proto3" json:"blocked,omitempty"`
	// Deprecated repositories are labeled as such and hidden from global search
	// results.
	Deprecated bool `protobuf:"varint,11,opt,name=deprecated,proto3" json:"deprecated,omitempty"`
	// Fork is whether this repository is a fork.
	Fork bool `protobuf:"varint,12,opt,name=fork,proto3" json:"fork,omitempty"`
	// Mirror indicates whether this repo's canonical location is on
	// another server. Mirror repos track their upstream.
	Mirror bool `protobuf:"varint,13,opt,name=mirror,proto3" json:"mirror,omitempty"`
	// Private is whether this repository is private.
	Private bool `protobuf:"varint,14,opt,name=private,proto3" json:"private,omitempty"`
	// CreatedAt is when this repository was created. If it represents an externally
	// hosted (e.g., GitHub) repository, the creation date is when it was created at
	// that origin.
	CreatedAt pbtypes.Timestamp `protobuf:"bytes,15,opt,name=created_at" json:"created_at"`
	// UpdatedAt is when this repository's metadata was last updated (on its origin if
	// it's an externally hosted repository).
	UpdatedAt pbtypes.Timestamp `protobuf:"bytes,16,opt,name=updated_at" json:"updated_at"`
	// PushedAt is when this repository's was last (VCS-)pushed to.
	PushedAt pbtypes.Timestamp `protobuf:"bytes,17,opt,name=pushed_at" json:"pushed_at"`
	// Permissions describes the permissions that the current user (or anonymous users,
	// if there is no current user) is granted to this repository.
	Permissions *RepoPermissions `protobuf:"bytes,18,opt,name=permissions" json:"permissions,omitempty"`
	GitHub      *GitHubRepo      `protobuf:"bytes,19,opt,name=github" json:"github,omitempty"`
	Config      *RepoConfig      `protobuf:"bytes,20,opt,name=config" json:"config,omitempty"`
}

func (m *Repo) Reset()         { *m = Repo{} }
func (m *Repo) String() string { return proto.CompactTextString(m) }
func (*Repo) ProtoMessage()    {}

type BadgeList struct {
	Badges []*Badge `protobuf:"bytes,1,rep,name=badges" json:"badges,omitempty"`
}

func (m *BadgeList) Reset()         { *m = BadgeList{} }
func (m *BadgeList) String() string { return proto.CompactTextString(m) }
func (*BadgeList) ProtoMessage()    {}

type CounterList struct {
	Counters []*Counter `protobuf:"bytes,1,rep,name=counters" json:"counters,omitempty"`
}

func (m *CounterList) Reset()         { *m = CounterList{} }
func (m *CounterList) String() string { return proto.CompactTextString(m) }
func (*CounterList) ProtoMessage()    {}

type RepoBadgesCountHitsOp struct {
	Repo  RepoSpec           `protobuf:"bytes,1,opt,name=repo" json:"repo"`
	Since *pbtypes.Timestamp `protobuf:"bytes,2,opt,name=since" json:"since,omitempty"`
}

func (m *RepoBadgesCountHitsOp) Reset()         { *m = RepoBadgesCountHitsOp{} }
func (m *RepoBadgesCountHitsOp) String() string { return proto.CompactTextString(m) }
func (*RepoBadgesCountHitsOp) ProtoMessage()    {}

type RepoBadgesCountHitsResult struct {
	Hits int32 `protobuf:"varint,1,opt,name=hits,proto3" json:"hits,omitempty"`
}

func (m *RepoBadgesCountHitsResult) Reset()         { *m = RepoBadgesCountHitsResult{} }
func (m *RepoBadgesCountHitsResult) String() string { return proto.CompactTextString(m) }
func (*RepoBadgesCountHitsResult) ProtoMessage()    {}

type RepoListOptions struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty" url:",omitempty"`
	// Specifies a search query for repositories. If specified, then the Sort and
	// Direction options are ignored
	Query       string   `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty" url:",omitempty"`
	URIs        []string `protobuf:"bytes,3,rep,name=uri_s" json:"uri_s,omitempty" url:",comma,omitempty"`
	BuiltOnly   bool     `protobuf:"varint,4,opt,name=built_only,proto3" json:"built_only,omitempty" url:",omitempty"`
	Sort        string   `protobuf:"bytes,5,opt,name=sort,proto3" json:"sort,omitempty" url:",omitempty"`
	Direction   string   `protobuf:"bytes,6,opt,name=direction,proto3" json:"direction,omitempty" url:",omitempty"`
	NoFork      bool     `protobuf:"varint,7,opt,name=no_fork,proto3" json:"no_fork,omitempty" url:",omitempty"`
	Type        string   `protobuf:"bytes,8,opt,name=type,proto3" json:"type,omitempty" url:",omitempty"`
	State       string   `protobuf:"bytes,9,opt,name=state,proto3" json:"state,omitempty" url:",omitempty"`
	Owner       string   `protobuf:"bytes,10,opt,name=owner,proto3" json:"owner,omitempty" url:",omitempty"`
	ListOptions `protobuf:"bytes,11,opt,name=list_options,embedded=list_options" json:"list_options"`
}

func (m *RepoListOptions) Reset()         { *m = RepoListOptions{} }
func (m *RepoListOptions) String() string { return proto.CompactTextString(m) }
func (*RepoListOptions) ProtoMessage()    {}

// RepoPermissions describes the possible permissions that a user (or an anonymous
// user) can be granted to a repository.
type RepoPermissions struct {
	Read  bool `protobuf:"varint,1,opt,name=read,proto3" json:"read,omitempty"`
	Write bool `protobuf:"varint,2,opt,name=write,proto3" json:"write,omitempty"`
	Admin bool `protobuf:"varint,3,opt,name=admin,proto3" json:"admin,omitempty"`
}

func (m *RepoPermissions) Reset()         { *m = RepoPermissions{} }
func (m *RepoPermissions) String() string { return proto.CompactTextString(m) }
func (*RepoPermissions) ProtoMessage()    {}

// RepoRevSpec specifies a repository at a specific commit (or revision specifier,
// such as a branch, which is resolved on the server side to a specific commit).
//
// Filling in CommitID is an optional optimization. It avoids the need for another
// resolution of Rev. If CommitID is filled in, the "Rev" route variable becomes
// "Rev===CommitID" (e.g., "master===af4cd6"). Handlers can parse this string to
// retrieve the pre-resolved commit ID (e.g., "af4cd6") and still return data that
// constructs URLs using the unresolved revspec (e.g., "master").
//
// Why is it important/useful to pass the resolved commit ID instead of just using
// a revspec everywhere? Consider this case. Your application wants to make a bunch
// of requests for resources relating to "master"; for example, it wants to
// retrieve a source file foo.go at master and all of the definitions and
// references contained in the file. This may consist of dozens of API calls. If
// each API call specified just "master", there would be 2 problems: (1) each API
// call would have to re-resolve "master" to its actual commit ID, which takes a
// lot of extra work; and (2) if the "master" ref changed during the API calls (if
// someone pushed in the middle of the API call, for example), then your
// application would receive data from 2 different commits. The solution is for
// your application to resolve the revspec once and pass both the original revspec
// and the resolved commit ID in all API calls it makes.
//
// And why do we want to preserve the unresolved revspec? In this case, your app
// wants to let the user continue browsing "master". If the API data all referred
// to a specific commit ID, then the user would cease browsing master the next time
// she clicked a link on your app. Preserving the revspec gives the user a choice
// whether to use the absolute commit ID or the revspec (similar to how GitHub lets
// you canonicalize a URL with 'y' but does not default to using the canonical
// URL).
type RepoRevSpec struct {
	RepoSpec `protobuf:"bytes,1,opt,name=repo_spec,embedded=repo_spec" json:"repo_spec"`
	Rev      string `protobuf:"bytes,2,opt,name=rev,proto3" json:"rev,omitempty"`
	CommitID string `protobuf:"bytes,3,opt,name=commit_id,proto3" json:"commit_id,omitempty"`
}

func (m *RepoRevSpec) Reset()         { *m = RepoRevSpec{} }
func (m *RepoRevSpec) String() string { return proto.CompactTextString(m) }
func (*RepoRevSpec) ProtoMessage()    {}

// RepoSpec specifies a repository.
type RepoSpec struct {
	URI string `protobuf:"bytes,1,opt,name=uri,proto3" json:"uri,omitempty"`
}

func (m *RepoSpec) Reset()         { *m = RepoSpec{} }
func (m *RepoSpec) String() string { return proto.CompactTextString(m) }
func (*RepoSpec) ProtoMessage()    {}

// RepoStatus is the status of the repository at a specific rev (in a single
// context).
type RepoStatus struct {
	// State is the current status of the repository. Possible values are: pending,
	// success, error, or failure.
	State string `protobuf:"bytes,2,opt,name=state,proto3" json:"state,omitempty"`
	// TargetURL is the URL of the page representing this status. It will be linked
	// from the UI to allow users to see the source of the status.
	TargetURL string `protobuf:"bytes,3,opt,name=target_url,proto3" json:"target_url,omitempty"`
	// Description is a short, high-level summary of the status.
	Description string `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	// A string label to differentiate this status from the statuses of other systems.
	Context   string            `protobuf:"bytes,5,opt,name=context,proto3" json:"context,omitempty"`
	CreatedAt pbtypes.Timestamp `protobuf:"bytes,6,opt,name=created_at" json:"created_at"`
	UpdatedAt pbtypes.Timestamp `protobuf:"bytes,7,opt,name=updated_at" json:"updated_at"`
}

func (m *RepoStatus) Reset()         { *m = RepoStatus{} }
func (m *RepoStatus) String() string { return proto.CompactTextString(m) }
func (*RepoStatus) ProtoMessage()    {}

type RepoStatusesCreateOp struct {
	Repo   RepoRevSpec `protobuf:"bytes,1,opt,name=repo" json:"repo"`
	Status RepoStatus  `protobuf:"bytes,2,opt,name=status" json:"status"`
}

func (m *RepoStatusesCreateOp) Reset()         { *m = RepoStatusesCreateOp{} }
func (m *RepoStatusesCreateOp) String() string { return proto.CompactTextString(m) }
func (*RepoStatusesCreateOp) ProtoMessage()    {}

type RepoList struct {
	Repos []*Repo `protobuf:"bytes,1,rep,name=repos" json:"repos,omitempty"`
}

func (m *RepoList) Reset()         { *m = RepoList{} }
func (m *RepoList) String() string { return proto.CompactTextString(m) }
func (*RepoList) ProtoMessage()    {}

type ReposCreateOp struct {
	// URI is the desired URI of the new repository.
	URI string `protobuf:"bytes,1,opt,name=uri,proto3" json:"uri,omitempty"`
	// VCS is the desired VCS type of the new repository (only "git"
	// is currently supported).
	VCS string `protobuf:"bytes,2,opt,name=vcs,proto3" json:"vcs,omitempty"`
	// CloneURL is the clone URL of the repository for mirrored
	// repositories. If blank, a new hosted repository is created
	// (i.e., a repo whose origin is on the server). If Mirror is
	// true, a clone URL must be provided.
	CloneURL string `protobuf:"bytes,3,opt,name=clone_url,proto3" json:"clone_url,omitempty"`
	// Mirror is a boolean value indicating whether the newly created
	// repository should be a mirror. Mirror repositories are
	// periodically updated to track their upstream (which is
	// specified using the CloneURL field of this message).
	Mirror bool `protobuf:"varint,4,opt,name=mirror,proto3" json:"mirror,omitempty"`
}

func (m *ReposCreateOp) Reset()         { *m = ReposCreateOp{} }
func (m *ReposCreateOp) String() string { return proto.CompactTextString(m) }
func (*ReposCreateOp) ProtoMessage()    {}

type ReposListCommitsOp struct {
	Repo RepoSpec                `protobuf:"bytes,1,opt,name=repo" json:"repo"`
	Opt  *RepoListCommitsOptions `protobuf:"bytes,2,opt,name=opt" json:"opt,omitempty"`
}

func (m *ReposListCommitsOp) Reset()         { *m = ReposListCommitsOp{} }
func (m *ReposListCommitsOp) String() string { return proto.CompactTextString(m) }
func (*ReposListCommitsOp) ProtoMessage()    {}

type RepoListCommitsOptions struct {
	Head         string `protobuf:"bytes,1,opt,name=head,proto3" json:"head,omitempty" url:",omitempty"`
	Base         string `protobuf:"bytes,2,opt,name=base,proto3" json:"base,omitempty" url:",omitempty"`
	ListOptions  `protobuf:"bytes,3,opt,name=list_options,embedded=list_options" json:"list_options"`
	Path         string `protobuf:"bytes,4,opt,name=path,proto3" json:"path,omitempty" url:",omitempty"`
	RefreshCache bool   `protobuf:"varint,5,opt,name=refresh_cache,proto3" json:"refresh_cache,omitempty" url:",omitempty"`
}

func (m *RepoListCommitsOptions) Reset()         { *m = RepoListCommitsOptions{} }
func (m *RepoListCommitsOptions) String() string { return proto.CompactTextString(m) }
func (*RepoListCommitsOptions) ProtoMessage()    {}

type CommitList struct {
	Commits      []*vcs.Commit `protobuf:"bytes,1,rep,name=commits" json:"commits,omitempty"`
	ListResponse `protobuf:"bytes,2,opt,name=list_response,embedded=list_response" json:"list_response"`
}

func (m *CommitList) Reset()         { *m = CommitList{} }
func (m *CommitList) String() string { return proto.CompactTextString(m) }
func (*CommitList) ProtoMessage()    {}

type ReposListBranchesOp struct {
	Repo RepoSpec                 `protobuf:"bytes,1,opt,name=repo" json:"repo"`
	Opt  *RepoListBranchesOptions `protobuf:"bytes,2,opt,name=opt" json:"opt,omitempty"`
}

func (m *ReposListBranchesOp) Reset()         { *m = ReposListBranchesOp{} }
func (m *ReposListBranchesOp) String() string { return proto.CompactTextString(m) }
func (*ReposListBranchesOp) ProtoMessage()    {}

type RepoListBranchesOptions struct {
	IncludeCommit     bool   `protobuf:"varint,4,opt,name=include_commit,proto3" json:"include_commit,omitempty"`
	BehindAheadBranch string `protobuf:"bytes,5,opt,name=behind_ahead_branch,proto3" json:"behind_ahead_branch,omitempty"`
	ContainsCommit    string `protobuf:"bytes,6,opt,name=contains_commit,proto3" json:"contains_commit,omitempty"`
	ListOptions       `protobuf:"bytes,3,opt,name=list_options,embedded=list_options" json:"list_options"`
}

func (m *RepoListBranchesOptions) Reset()         { *m = RepoListBranchesOptions{} }
func (m *RepoListBranchesOptions) String() string { return proto.CompactTextString(m) }
func (*RepoListBranchesOptions) ProtoMessage()    {}

type BranchList struct {
	Branches     []*vcs.Branch `protobuf:"bytes,1,rep,name=branches" json:"branches,omitempty"`
	ListResponse `protobuf:"bytes,2,opt,name=list_response,embedded=list_response" json:"list_response"`
}

func (m *BranchList) Reset()         { *m = BranchList{} }
func (m *BranchList) String() string { return proto.CompactTextString(m) }
func (*BranchList) ProtoMessage()    {}

type ReposListTagsOp struct {
	Repo RepoSpec             `protobuf:"bytes,1,opt,name=repo" json:"repo"`
	Opt  *RepoListTagsOptions `protobuf:"bytes,2,opt,name=opt" json:"opt,omitempty"`
}

func (m *ReposListTagsOp) Reset()         { *m = ReposListTagsOp{} }
func (m *ReposListTagsOp) String() string { return proto.CompactTextString(m) }
func (*ReposListTagsOp) ProtoMessage()    {}

type ReposListCommittersOp struct {
	Repo RepoSpec                   `protobuf:"bytes,1,opt,name=repo" json:"repo"`
	Opt  *RepoListCommittersOptions `protobuf:"bytes,2,opt,name=opt" json:"opt,omitempty"`
}

func (m *ReposListCommittersOp) Reset()         { *m = ReposListCommittersOp{} }
func (m *ReposListCommittersOp) String() string { return proto.CompactTextString(m) }
func (*ReposListCommittersOp) ProtoMessage()    {}

type RepoListCommittersOptions struct {
	Rev         string `protobuf:"bytes,1,opt,name=rev,proto3" json:"rev,omitempty"`
	ListOptions `protobuf:"bytes,2,opt,name=list_options,embedded=list_options" json:"list_options"`
}

func (m *RepoListCommittersOptions) Reset()         { *m = RepoListCommittersOptions{} }
func (m *RepoListCommittersOptions) String() string { return proto.CompactTextString(m) }
func (*RepoListCommittersOptions) ProtoMessage()    {}

type CommitterList struct {
	Committers   []*vcs.Committer `protobuf:"bytes,1,rep,name=committers" json:"committers,omitempty"`
	ListResponse `protobuf:"bytes,2,opt,name=list_response,embedded=list_response" json:"list_response"`
}

func (m *CommitterList) Reset()         { *m = CommitterList{} }
func (m *CommitterList) String() string { return proto.CompactTextString(m) }
func (*CommitterList) ProtoMessage()    {}

type ChangesetCreateOp struct {
	Repo      RepoSpec   `protobuf:"bytes,1,opt,name=repo" json:"repo"`
	Changeset *Changeset `protobuf:"bytes,2,opt,name=changeset" json:"changeset,omitempty"`
}

func (m *ChangesetCreateOp) Reset()         { *m = ChangesetCreateOp{} }
func (m *ChangesetCreateOp) String() string { return proto.CompactTextString(m) }
func (*ChangesetCreateOp) ProtoMessage()    {}

type ChangesetCreateReviewOp struct {
	Repo        RepoSpec         `protobuf:"bytes,1,opt,name=repo" json:"repo"`
	ChangesetID int64            `protobuf:"varint,2,opt,name=changeset_id,proto3" json:"changeset_id,omitempty"`
	Review      *ChangesetReview `protobuf:"bytes,3,opt,name=review" json:"review,omitempty"`
}

func (m *ChangesetCreateReviewOp) Reset()         { *m = ChangesetCreateReviewOp{} }
func (m *ChangesetCreateReviewOp) String() string { return proto.CompactTextString(m) }
func (*ChangesetCreateReviewOp) ProtoMessage()    {}

type ChangesetListReviewsOp struct {
	Repo        RepoSpec `protobuf:"bytes,1,opt,name=repo" json:"repo"`
	ChangesetID int64    `protobuf:"varint,2,opt,name=changeset_id,proto3" json:"changeset_id,omitempty"`
}

func (m *ChangesetListReviewsOp) Reset()         { *m = ChangesetListReviewsOp{} }
func (m *ChangesetListReviewsOp) String() string { return proto.CompactTextString(m) }
func (*ChangesetListReviewsOp) ProtoMessage()    {}

type ChangesetSpec struct {
	Repo RepoSpec `protobuf:"bytes,1,opt,name=repo" json:"repo"`
	ID   int64    `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *ChangesetSpec) Reset()         { *m = ChangesetSpec{} }
func (m *ChangesetSpec) String() string { return proto.CompactTextString(m) }
func (*ChangesetSpec) ProtoMessage()    {}

type ChangesetUpdateOp struct {
	// Repo holds the RepoSpec where the Changeset to be updated is located.
	Repo RepoSpec `protobuf:"bytes,1,opt,name=repo" json:"repo"`
	// ID holds the ID of the changeset that is to be updated.
	ID int64 `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
	// Title, if non-empty, will be set as the new title of the changeset.
	Title string `protobuf:"bytes,3,opt,name=title,proto3" json:"title,omitempty"`
	// Description, if specified, will become the new description of the changeset.
	Description string `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	// Open, if true, will set the changeset's ClosedAt value to nil.
	Open bool `protobuf:"varint,5,opt,name=open,proto3" json:"open,omitempty"`
	// Close, if true, will set the ClosedAt date.
	Close bool `protobuf:"varint,6,opt,name=close,proto3" json:"close,omitempty"`
	// Merged, if true, will update the changeset to indicate that it was priorly
	// merged.
	Merged bool `protobuf:"varint,7,opt,name=merged,proto3" json:"merged,omitempty"`
	// Author is the user that initiated this event.
	Author UserSpec `protobuf:"bytes,8,opt" json:"Author"`
}

func (m *ChangesetUpdateOp) Reset()         { *m = ChangesetUpdateOp{} }
func (m *ChangesetUpdateOp) String() string { return proto.CompactTextString(m) }
func (*ChangesetUpdateOp) ProtoMessage()    {}

type DiscussionSpec struct {
	Repo RepoSpec `protobuf:"bytes,1,opt,name=repo" json:"repo"`
	ID   int64    `protobuf:"varint,2,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *DiscussionSpec) Reset()         { *m = DiscussionSpec{} }
func (m *DiscussionSpec) String() string { return proto.CompactTextString(m) }
func (*DiscussionSpec) ProtoMessage()    {}

type DiscussionListOp struct {
	DefKey graph.DefKey `protobuf:"bytes,1,opt,name=def_key" json:"def_key"`
}

func (m *DiscussionListOp) Reset()         { *m = DiscussionListOp{} }
func (m *DiscussionListOp) String() string { return proto.CompactTextString(m) }
func (*DiscussionListOp) ProtoMessage()    {}

type DiscussionCommentCreateOp struct {
	DiscussionID int64              `protobuf:"varint,1,opt,name=discussion_id,proto3" json:"discussion_id,omitempty"`
	Comment      *DiscussionComment `protobuf:"bytes,2,opt,name=comment" json:"comment,omitempty"`
}

func (m *DiscussionCommentCreateOp) Reset()         { *m = DiscussionCommentCreateOp{} }
func (m *DiscussionCommentCreateOp) String() string { return proto.CompactTextString(m) }
func (*DiscussionCommentCreateOp) ProtoMessage()    {}

type DiscussionRatingUpdateOp struct {
	DiscussionID int64     `protobuf:"varint,1,opt,name=discussion_id,proto3" json:"discussion_id,omitempty"`
	User         *UserSpec `protobuf:"bytes,2,opt,name=user" json:"user,omitempty"`
}

func (m *DiscussionRatingUpdateOp) Reset()         { *m = DiscussionRatingUpdateOp{} }
func (m *DiscussionRatingUpdateOp) String() string { return proto.CompactTextString(m) }
func (*DiscussionRatingUpdateOp) ProtoMessage()    {}

type RepoListTagsOptions struct {
	ListOptions `protobuf:"bytes,3,opt,name=list_options,embedded=list_options" json:"list_options"`
}

func (m *RepoListTagsOptions) Reset()         { *m = RepoListTagsOptions{} }
func (m *RepoListTagsOptions) String() string { return proto.CompactTextString(m) }
func (*RepoListTagsOptions) ProtoMessage()    {}

type TagList struct {
	Tags         []*vcs.Tag `protobuf:"bytes,1,rep,name=tags" json:"tags,omitempty"`
	ListResponse `protobuf:"bytes,2,opt,name=list_response,embedded=list_response" json:"list_response"`
}

func (m *TagList) Reset()         { *m = TagList{} }
func (m *TagList) String() string { return proto.CompactTextString(m) }
func (*TagList) ProtoMessage()    {}

type MirroredRepoSSHKeysCreateOp struct {
	Repo RepoSpec      `protobuf:"bytes,1,opt,name=repo" json:"repo"`
	Key  SSHPrivateKey `protobuf:"bytes,2,opt,name=key" json:"key"`
}

func (m *MirroredRepoSSHKeysCreateOp) Reset()         { *m = MirroredRepoSSHKeysCreateOp{} }
func (m *MirroredRepoSSHKeysCreateOp) String() string { return proto.CompactTextString(m) }
func (*MirroredRepoSSHKeysCreateOp) ProtoMessage()    {}

// An SSHPrivateKey is an SSH key used to access a repository.
type SSHPrivateKey struct {
	// PEM is the encoded key.
	PEM []byte `protobuf:"bytes,2,opt,name=pem,proto3" json:"pem,omitempty"`
}

func (m *SSHPrivateKey) Reset()         { *m = SSHPrivateKey{} }
func (m *SSHPrivateKey) String() string { return proto.CompactTextString(m) }
func (*SSHPrivateKey) ProtoMessage()    {}

// A Build represents a scheduled, completed, or failed repository analysis and
// import job.
//
// A build is composed of many tasks. The worker that is responsible for a build or
// task determines whether a task failure causes the whole build to fail. (Keep
// reading to see how we determine who is responsible for a build or task.) There
// is no single kind of worker; currently there are 2 things that could be
// considered workers because they build builds or perform tasks: the builders on
// Sourcegraph.com, and anyone who runs `src push` locally.
//
// Each task has logs associated with it, and each task can be associated with a
// single source unit (or not).
//
// Builds have a Queue bool field. If a process creates a build that
// has Queue=true, that means that it relinquishes responsibility for
// it; some other queue workers (on the server, for example) will
// dequeue and complete it. If Queue=false, then the process that
// created it is responsible for completing it. The only exception to
// this is that after a certain timeout (on the order of 45 minutes),
// started but unfinished builds are marked as failed.
//
// Builds and tasks are simple "build"ing blocks (no pun intended) with simple
// behavior. As we encounter new requirements for the build system, they may
// evolve.
type Build struct {
	// Attempt is the 1-indexed number representing sequential attempts at building
	// this repository.
	Attempt uint32 `protobuf:"varint,1,opt,name=attempt,proto3" json:"attempt,omitempty"`
	// Repo is the URI of the repository this build is for.
	Repo string `protobuf:"bytes,2,opt,name=repo,proto3" json:"repo,omitempty"`
	// CommitID is the full resolved commit ID to build.
	CommitID    string             `protobuf:"bytes,3,opt,name=commit_id,proto3" json:"commit_id,omitempty"`
	CreatedAt   pbtypes.Timestamp  `protobuf:"bytes,4,opt,name=created_at" json:"created_at"`
	StartedAt   *pbtypes.Timestamp `protobuf:"bytes,5,opt,name=started_at" json:"started_at,omitempty"`
	EndedAt     *pbtypes.Timestamp `protobuf:"bytes,6,opt,name=ended_at" json:"ended_at,omitempty"`
	HeartbeatAt *pbtypes.Timestamp `protobuf:"bytes,7,opt,name=heartbeat_at" json:"heartbeat_at,omitempty"`
	Success     bool               `protobuf:"varint,8,opt,name=success,proto3" json:"success,omitempty"`
	Failure     bool               `protobuf:"varint,9,opt,name=failure,proto3" json:"failure,omitempty"`
	// Killed is true if this build's worker didn't exit on its own accord. It is
	// generally set when no heartbeat has been received within a certain interval. If
	// Killed is true, then Failure must also always be set to true. Unqueued builds
	// are never killed for lack of a heartbeat.
	Killed bool `protobuf:"varint,10,opt,name=killed,proto3" json:"killed,omitempty"`
	// Host is the hostname of the machine that is working on this build.
	Host        string `protobuf:"bytes,11,opt,name=host,proto3" json:"host,omitempty"`
	Purged      bool   `protobuf:"varint,12,opt,name=purged,proto3" json:"purged,omitempty"`
	BuildConfig `protobuf:"bytes,13,opt,name=build_config,embedded=build_config" json:"build_config"`
}

func (m *Build) Reset()         { *m = Build{} }
func (m *Build) String() string { return proto.CompactTextString(m) }
func (*Build) ProtoMessage()    {}

// BuildConfig configures a repository build.
type BuildConfig struct {
	// Import is whether to import the build data into the database
	// when the build is complete. The data must be imported for
	// Sourcegraph's web app or API to use it.
	Import bool `protobuf:"varint,1,opt,name=import,proto3" json:"import,omitempty"`
	// Queue is whether this build should be enqueued. If enqueued, any worker may
	// begin running this build. If not enqueued, it is up to the client to run the
	// build and update it accordingly.
	Queue bool `protobuf:"varint,2,opt,name=queue,proto3" json:"queue,omitempty"`
	// UseCache is whether to use cached build data files. If false, the
	// .sourcegraph-data directory will be wiped out before the build begins.
	//
	// Regardless of the value of UseCache, the build data files will be uploaded to
	// the central cache after the build ends.
	UseCache bool `protobuf:"varint,3,opt,name=use_cache,proto3" json:"use_cache,omitempty"`
	// Priority of the build in the queue (higher numbers mean the build is dequeued
	// sooner).
	Priority int32 `protobuf:"varint,4,opt,name=priority,proto3" json:"priority,omitempty"`
}

func (m *BuildConfig) Reset()         { *m = BuildConfig{} }
func (m *BuildConfig) String() string { return proto.CompactTextString(m) }
func (*BuildConfig) ProtoMessage()    {}

type BuildCreateOptions struct {
	BuildConfig `protobuf:"bytes,1,opt,name=build_config,embedded=build_config" json:"build_config"`
	// Force creation of build. If false, the build will not be created if a build for
	// the same repository and with the same BuildConfig exists.
	//
	// TODO(bliu): test this
	Force bool `protobuf:"varint,2,opt,name=force,proto3" json:"force,omitempty"`
}

func (m *BuildCreateOptions) Reset()         { *m = BuildCreateOptions{} }
func (m *BuildCreateOptions) String() string { return proto.CompactTextString(m) }
func (*BuildCreateOptions) ProtoMessage()    {}

// BuildGetLogOptions specifies options for build log API methods.
type BuildGetLogOptions struct {
	// MinID indicates that only log entries whose monotonically increasing ID is
	// greater than MinID should be returned.
	//
	// To "tail -f" or watch a log for updates, set each subsequent request's MinID to
	// the MaxID of the previous request.
	MinID string `protobuf:"bytes,1,opt,name=min_id,proto3" json:"min_id,omitempty"`
}

func (m *BuildGetLogOptions) Reset()         { *m = BuildGetLogOptions{} }
func (m *BuildGetLogOptions) String() string { return proto.CompactTextString(m) }
func (*BuildGetLogOptions) ProtoMessage()    {}

type BuildListOptions struct {
	Queued      bool   `protobuf:"varint,1,opt,name=queued,proto3" json:"queued,omitempty" url:",omitempty"`
	Active      bool   `protobuf:"varint,2,opt,name=active,proto3" json:"active,omitempty" url:",omitempty"`
	Ended       bool   `protobuf:"varint,3,opt,name=ended,proto3" json:"ended,omitempty" url:",omitempty"`
	Succeeded   bool   `protobuf:"varint,4,opt,name=succeeded,proto3" json:"succeeded,omitempty" url:",omitempty"`
	Failed      bool   `protobuf:"varint,5,opt,name=failed,proto3" json:"failed,omitempty" url:",omitempty"`
	Purged      bool   `protobuf:"varint,6,opt,name=purged,proto3" json:"purged,omitempty" url:",omitempty"`
	Repo        string `protobuf:"bytes,7,opt,name=repo,proto3" json:"repo,omitempty" url:",omitempty"`
	CommitID    string `protobuf:"bytes,8,opt,name=commit_id,proto3" json:"commit_id,omitempty" url:",omitempty"`
	Sort        string `protobuf:"bytes,9,opt,name=sort,proto3" json:"sort,omitempty" url:",omitempty"`
	Direction   string `protobuf:"bytes,10,opt,name=direction,proto3" json:"direction,omitempty" url:",omitempty"`
	ListOptions `protobuf:"bytes,11,opt,name=list_options,embedded=list_options" json:"list_options"`
}

func (m *BuildListOptions) Reset()         { *m = BuildListOptions{} }
func (m *BuildListOptions) String() string { return proto.CompactTextString(m) }
func (*BuildListOptions) ProtoMessage()    {}

type ChangesetListOp struct {
	Repo string `protobuf:"bytes,1,opt,name=repo,proto3" json:"repo,omitempty"`
	// Open, when true, will only return open changesets.
	Open bool `protobuf:"varint,2,opt,name=open,proto3" json:"open,omitempty"`
	// Closed, when true, will only return closed changeset.
	Closed bool `protobuf:"varint,3,opt,name=closed,proto3" json:"closed,omitempty"`
	// Head, if set, will restrict the returned list to only changesets
	// that have this branch as head.
	Head string `protobuf:"bytes,4,opt,name=head,proto3" json:"head,omitempty"`
	// Base, when set, will restrict the list to changesets that have this
	// branch as a base.
	Base        string `protobuf:"bytes,5,opt,name=base,proto3" json:"base,omitempty"`
	ListOptions `protobuf:"bytes,11,opt,name=list_options,embedded=list_options" json:"list_options"`
}

func (m *ChangesetListOp) Reset()         { *m = ChangesetListOp{} }
func (m *ChangesetListOp) String() string { return proto.CompactTextString(m) }
func (*ChangesetListOp) ProtoMessage()    {}

type BuildSpec struct {
	CommitID string   `protobuf:"bytes,1,opt,name=commit_id,proto3" json:"commit_id,omitempty"`
	Attempt  uint32   `protobuf:"varint,2,opt,name=attempt,proto3" json:"attempt,omitempty"`
	Repo     RepoSpec `protobuf:"bytes,3,opt,name=repo" json:"repo"`
}

func (m *BuildSpec) Reset()         { *m = BuildSpec{} }
func (m *BuildSpec) String() string { return proto.CompactTextString(m) }
func (*BuildSpec) ProtoMessage()    {}

// A BuildTask represents an individual step of a build.
//
// See the documentation for Build for more information about how builds and tasks
// relate to each other.
type BuildTask struct {
	// TaskID is the unique ID of this task. It is unique over all tasks, not just
	// tasks in the same build.
	TaskID int64 `protobuf:"varint,1,opt,name=task_id,proto3" json:"task_id,omitempty"`
	// Repo is the URI of the repository that this task's build is for.
	Repo     string `protobuf:"bytes,2,opt,name=repo,proto3" json:"repo,omitempty"`
	CommitID string `protobuf:"bytes,3,opt,name=commit_id,proto3" json:"commit_id,omitempty"`
	Attempt  uint32 `protobuf:"varint,4,opt,name=attempt,proto3" json:"attempt,omitempty"`
	// UnitType is the srclib source unit type of the source unit that this task is
	// associated with.
	UnitType string `protobuf:"bytes,5,opt,name=unit_type,proto3" json:"unit_type,omitempty"`
	// Unit is the srclib source unit name of the source unit that this task is
	// associated with.
	Unit string `protobuf:"bytes,6,opt,name=unit,proto3" json:"unit,omitempty"`
	// Op is the srclib toolchain operation (graph, depresolve, etc.) that this task
	// performs.
	Op string `protobuf:"bytes,7,opt,name=op,proto3" json:"op,omitempty"`
	// Order is the order in which this task is performed, relative to other tasks in
	// the same build. Lower-number-ordered tasks are built first. Multiple tasks may
	// have the same order.
	Order int32 `protobuf:"varint,8,opt,name=order,proto3" json:"order,omitempty"`
	// CreatedAt is when this task was initially created.
	CreatedAt pbtypes.Timestamp `protobuf:"bytes,9,opt,name=created_at" json:"created_at"`
	// StartedAt is when this task's execution began.
	StartedAt *pbtypes.Timestamp `protobuf:"bytes,10,opt,name=started_at" json:"started_at,omitempty"`
	// EndedAt is when this task's execution ended (whether because it succeeded or
	// failed).
	EndedAt *pbtypes.Timestamp `protobuf:"bytes,11,opt,name=ended_at" json:"ended_at,omitempty"`
	// Success is whether this task's execution succeeded.
	Success bool `protobuf:"varint,13,opt,name=success,proto3" json:"success,omitempty"`
	// Failure is whether this task's execution failed.
	Failure bool `protobuf:"varint,14,opt,name=failure,proto3" json:"failure,omitempty"`
}

func (m *BuildTask) Reset()         { *m = BuildTask{} }
func (m *BuildTask) String() string { return proto.CompactTextString(m) }
func (*BuildTask) ProtoMessage()    {}

type BuildTaskListOptions struct {
	ListOptions `protobuf:"bytes,1,opt,name=list_options,embedded=list_options" json:"list_options"`
}

func (m *BuildTaskListOptions) Reset()         { *m = BuildTaskListOptions{} }
func (m *BuildTaskListOptions) String() string { return proto.CompactTextString(m) }
func (*BuildTaskListOptions) ProtoMessage()    {}

// A BuildUpdate contains updated information to update on an existing build.
type BuildUpdate struct {
	StartedAt   *pbtypes.Timestamp `protobuf:"bytes,1,opt,name=started_at" json:"started_at,omitempty"`
	EndedAt     *pbtypes.Timestamp `protobuf:"bytes,2,opt,name=ended_at" json:"ended_at,omitempty"`
	HeartbeatAt *pbtypes.Timestamp `protobuf:"bytes,3,opt,name=heartbeat_at" json:"heartbeat_at,omitempty"`
	Host        string             `protobuf:"bytes,4,opt,name=host,proto3" json:"host,omitempty"`
	Success     bool               `protobuf:"varint,5,opt,name=success,proto3" json:"success,omitempty"`
	Purged      bool               `protobuf:"varint,6,opt,name=purged,proto3" json:"purged,omitempty"`
	Failure     bool               `protobuf:"varint,7,opt,name=failure,proto3" json:"failure,omitempty"`
	Killed      bool               `protobuf:"varint,8,opt,name=killed,proto3" json:"killed,omitempty"`
	Priority    int32              `protobuf:"varint,9,opt,name=priority,proto3" json:"priority,omitempty"`
}

func (m *BuildUpdate) Reset()         { *m = BuildUpdate{} }
func (m *BuildUpdate) String() string { return proto.CompactTextString(m) }
func (*BuildUpdate) ProtoMessage()    {}

// BuildsGetRepoBuildInfoOptions sets options for the Repos.GetBuild call.
type BuildsGetRepoBuildInfoOptions struct {
	// Exact is whether only a build whose commit ID exactly matches the revspec should
	// be returned. (For non-full-commit ID revspecs, such as branches, tags, and
	// partial commit IDs, this means that the build's commit ID matches the resolved
	// revspec's commit ID.)
	//
	// If Exact is false, then builds for older commits that are reachable from the
	// revspec may also be returned. For example, if there's a build for master~1 but
	// no build for master, and your revspec is master, using Exact=false will return
	// the build for master~1.
	//
	// Using Exact=true is faster as the commit and build history never needs to be
	// searched. If the exact build is not found, or the exact build was found but it
	// failed, LastSuccessful and LastSuccessfulCommit for RepoBuildInfo will be nil.
	Exact bool `protobuf:"varint,1,opt,name=exact,proto3" json:"exact,omitempty" url:",omitempty"`
	// IncludeVCSMetadata is whether the returned RepoBuildInfo should
	// set the VCS-related fields (CommitsBehind, LastSuccessfulCommit).
	// These require an extra VCS lookup operation to compute.
	IncludeVCSMetadata bool `protobuf:"varint,2,opt,name=include_vcs_metadata,proto3" json:"include_vcs_metadata,omitempty" url:",omitempty"`
}

func (m *BuildsGetRepoBuildInfoOptions) Reset()         { *m = BuildsGetRepoBuildInfoOptions{} }
func (m *BuildsGetRepoBuildInfoOptions) String() string { return proto.CompactTextString(m) }
func (*BuildsGetRepoBuildInfoOptions) ProtoMessage()    {}

type BuildsGetRepoBuildInfoOp struct {
	Repo RepoRevSpec                    `protobuf:"bytes,1,opt,name=repo" json:"repo"`
	Opt  *BuildsGetRepoBuildInfoOptions `protobuf:"bytes,2,opt,name=opt" json:"opt,omitempty"`
}

func (m *BuildsGetRepoBuildInfoOp) Reset()         { *m = BuildsGetRepoBuildInfoOp{} }
func (m *BuildsGetRepoBuildInfoOp) String() string { return proto.CompactTextString(m) }
func (*BuildsGetRepoBuildInfoOp) ProtoMessage()    {}

type BuildList struct {
	Builds       []*Build `protobuf:"bytes,1,rep,name=builds" json:"builds,omitempty"`
	ListResponse `protobuf:"bytes,2,opt,name=list_response,embedded=list_response" json:"list_response"`
}

func (m *BuildList) Reset()         { *m = BuildList{} }
func (m *BuildList) String() string { return proto.CompactTextString(m) }
func (*BuildList) ProtoMessage()    {}

type BuildsCreateOp struct {
	RepoRev RepoRevSpec         `protobuf:"bytes,1,opt,name=repo_rev" json:"repo_rev"`
	Opt     *BuildCreateOptions `protobuf:"bytes,2,opt,name=opt" json:"opt,omitempty"`
}

func (m *BuildsCreateOp) Reset()         { *m = BuildsCreateOp{} }
func (m *BuildsCreateOp) String() string { return proto.CompactTextString(m) }
func (*BuildsCreateOp) ProtoMessage()    {}

type BuildsUpdateOp struct {
	Build BuildSpec   `protobuf:"bytes,1,opt,name=build" json:"build"`
	Info  BuildUpdate `protobuf:"bytes,2,opt,name=info" json:"info"`
}

func (m *BuildsUpdateOp) Reset()         { *m = BuildsUpdateOp{} }
func (m *BuildsUpdateOp) String() string { return proto.CompactTextString(m) }
func (*BuildsUpdateOp) ProtoMessage()    {}

type BuildsListBuildTasksOp struct {
	Build BuildSpec             `protobuf:"bytes,1,opt,name=build" json:"build"`
	Opt   *BuildTaskListOptions `protobuf:"bytes,2,opt,name=opt" json:"opt,omitempty"`
}

func (m *BuildsListBuildTasksOp) Reset()         { *m = BuildsListBuildTasksOp{} }
func (m *BuildsListBuildTasksOp) String() string { return proto.CompactTextString(m) }
func (*BuildsListBuildTasksOp) ProtoMessage()    {}

type BuildTaskList struct {
	BuildTasks []*BuildTask `protobuf:"bytes,1,rep,name=build_tasks" json:"build_tasks,omitempty"`
}

func (m *BuildTaskList) Reset()         { *m = BuildTaskList{} }
func (m *BuildTaskList) String() string { return proto.CompactTextString(m) }
func (*BuildTaskList) ProtoMessage()    {}

type ChangesetReviewList struct {
	Reviews []*ChangesetReview `protobuf:"bytes,1,rep,name=reviews" json:"reviews,omitempty"`
}

func (m *ChangesetReviewList) Reset()         { *m = ChangesetReviewList{} }
func (m *ChangesetReviewList) String() string { return proto.CompactTextString(m) }
func (*ChangesetReviewList) ProtoMessage()    {}

type ChangesetList struct {
	Changesets []*Changeset `protobuf:"bytes,1,rep,name=changesets" json:"changesets,omitempty"`
}

func (m *ChangesetList) Reset()         { *m = ChangesetList{} }
func (m *ChangesetList) String() string { return proto.CompactTextString(m) }
func (*ChangesetList) ProtoMessage()    {}

type ChangesetEventList struct {
	Events []*ChangesetEvent `protobuf:"bytes,1,rep,name=events" json:"events,omitempty"`
}

func (m *ChangesetEventList) Reset()         { *m = ChangesetEventList{} }
func (m *ChangesetEventList) String() string { return proto.CompactTextString(m) }
func (*ChangesetEventList) ProtoMessage()    {}

type DiscussionList struct {
	Discussions []*Discussion `protobuf:"bytes,1,rep,name=discussions" json:"discussions,omitempty"`
}

func (m *DiscussionList) Reset()         { *m = DiscussionList{} }
func (m *DiscussionList) String() string { return proto.CompactTextString(m) }
func (*DiscussionList) ProtoMessage()    {}

type BuildsCreateTasksOp struct {
	Build BuildSpec    `protobuf:"bytes,1,opt,name=build" json:"build"`
	Tasks []*BuildTask `protobuf:"bytes,2,rep,name=tasks" json:"tasks,omitempty"`
}

func (m *BuildsCreateTasksOp) Reset()         { *m = BuildsCreateTasksOp{} }
func (m *BuildsCreateTasksOp) String() string { return proto.CompactTextString(m) }
func (*BuildsCreateTasksOp) ProtoMessage()    {}

type BuildsUpdateTaskOp struct {
	Task TaskSpec   `protobuf:"bytes,1,opt,name=task" json:"task"`
	Info TaskUpdate `protobuf:"bytes,2,opt,name=info" json:"info"`
}

func (m *BuildsUpdateTaskOp) Reset()         { *m = BuildsUpdateTaskOp{} }
func (m *BuildsUpdateTaskOp) String() string { return proto.CompactTextString(m) }
func (*BuildsUpdateTaskOp) ProtoMessage()    {}

type BuildsGetLogOp struct {
	Build BuildSpec           `protobuf:"bytes,1,opt,name=build" json:"build"`
	Opt   *BuildGetLogOptions `protobuf:"bytes,2,opt,name=opt" json:"opt,omitempty"`
}

func (m *BuildsGetLogOp) Reset()         { *m = BuildsGetLogOp{} }
func (m *BuildsGetLogOp) String() string { return proto.CompactTextString(m) }
func (*BuildsGetLogOp) ProtoMessage()    {}

type BuildsGetTaskLogOp struct {
	Task TaskSpec            `protobuf:"bytes,1,opt,name=task" json:"task"`
	Opt  *BuildGetLogOptions `protobuf:"bytes,2,opt,name=opt" json:"opt,omitempty"`
}

func (m *BuildsGetTaskLogOp) Reset()         { *m = BuildsGetTaskLogOp{} }
func (m *BuildsGetTaskLogOp) String() string { return proto.CompactTextString(m) }
func (*BuildsGetTaskLogOp) ProtoMessage()    {}

type BuildsDequeueNextOp struct {
}

func (m *BuildsDequeueNextOp) Reset()         { *m = BuildsDequeueNextOp{} }
func (m *BuildsDequeueNextOp) String() string { return proto.CompactTextString(m) }
func (*BuildsDequeueNextOp) ProtoMessage()    {}

// EmailAddr is an email address associated with a user.
type EmailAddr struct {
	// the email address (case-insensitively compared in the DB and API)
	Email string `protobuf:"bytes,1,opt,name=email,proto3" json:"email,omitempty"`
	// whether this email address has been verified
	Verified bool `protobuf:"varint,2,opt,name=verified,proto3" json:"verified,omitempty"`
	// indicates this is the user's primary email (only 1 email can be primary per user)
	Primary bool `protobuf:"varint,3,opt,name=primary,proto3" json:"primary,omitempty"`
	// whether Sourcegraph inferred via public data that this is an email for the user
	Guessed bool `protobuf:"varint,4,opt,name=guessed,proto3" json:"guessed,omitempty"`
	// indicates that this email should not be associated with the user (even if guessed in the future)
	Blacklisted bool `protobuf:"varint,5,opt,name=blacklisted,proto3" json:"blacklisted,omitempty"`
}

func (m *EmailAddr) Reset()         { *m = EmailAddr{} }
func (m *EmailAddr) String() string { return proto.CompactTextString(m) }
func (*EmailAddr) ProtoMessage()    {}

type LogEntries struct {
	MaxID   string   `protobuf:"bytes,1,opt,name=max_id,proto3" json:"max_id,omitempty"`
	Entries []string `protobuf:"bytes,2,rep,name=entries" json:"entries,omitempty"`
}

func (m *LogEntries) Reset()         { *m = LogEntries{} }
func (m *LogEntries) String() string { return proto.CompactTextString(m) }
func (*LogEntries) ProtoMessage()    {}

type Org struct {
	User `protobuf:"bytes,1,opt,name=user,embedded=user" json:"user"`
}

func (m *Org) Reset()         { *m = Org{} }
func (m *Org) String() string { return proto.CompactTextString(m) }
func (*Org) ProtoMessage()    {}

type OrgListMembersOptions struct {
	ListOptions `protobuf:"bytes,1,opt,name=list_options,embedded=list_options" json:"list_options"`
}

func (m *OrgListMembersOptions) Reset()         { *m = OrgListMembersOptions{} }
func (m *OrgListMembersOptions) String() string { return proto.CompactTextString(m) }
func (*OrgListMembersOptions) ProtoMessage()    {}

// OrgSpec specifies an organization. At least one of Email, Login, and UID must be
// nonempty.
type OrgSpec struct {
	Org string `protobuf:"bytes,1,opt,name=org,proto3" json:"org,omitempty"`
	UID int32  `protobuf:"varint,2,opt,name=uid,proto3" json:"uid,omitempty"`
}

func (m *OrgSpec) Reset()         { *m = OrgSpec{} }
func (m *OrgSpec) String() string { return proto.CompactTextString(m) }
func (*OrgSpec) ProtoMessage()    {}

type OrgsListMembersOp struct {
	Org OrgSpec                `protobuf:"bytes,1,opt,name=org" json:"org"`
	Opt *OrgListMembersOptions `protobuf:"bytes,2,opt,name=opt" json:"opt,omitempty"`
}

func (m *OrgsListMembersOp) Reset()         { *m = OrgsListMembersOp{} }
func (m *OrgsListMembersOp) String() string { return proto.CompactTextString(m) }
func (*OrgsListMembersOp) ProtoMessage()    {}

type UserList struct {
	Users []*User `protobuf:"bytes,1,rep,name=users" json:"users,omitempty"`
}

func (m *UserList) Reset()         { *m = UserList{} }
func (m *UserList) String() string { return proto.CompactTextString(m) }
func (*UserList) ProtoMessage()    {}

// A Person represents either a registered user or a committer to a repository
// (typically when their commit email can't be resolved to a user).
type Person struct {
	// PersonSpec is an identifier for the person. If the person was resolved to a
	// user, then both Login and UID are set. Otherwise only Email is set, and it may
	// be obfuscated (to protect privacy).
	PersonSpec `protobuf:"bytes,1,opt,name=person_spec,embedded=person_spec" json:"person_spec"`
	// FullName is the (possibly empty) full name of the person.
	FullName string `protobuf:"bytes,2,opt,name=full_name,proto3" json:"full_name,omitempty"`
	// AvatarURL is the URL to the user's avatar image.
	AvatarURL string `protobuf:"bytes,3,opt,name=avatar_url,proto3" json:"avatar_url,omitempty"`
}

func (m *Person) Reset()         { *m = Person{} }
func (m *Person) String() string { return proto.CompactTextString(m) }
func (*Person) ProtoMessage()    {}

// PersonSpec specifies a person. At least one of Email, Login, and UID must be
// nonempty.
type PersonSpec struct {
	// Email is a person's email address. It may be obfuscated (to protect privacy).
	Email string `protobuf:"bytes,1,opt,name=email,proto3" json:"email,omitempty"`
	// Login is a user's login.
	Login string `protobuf:"bytes,2,opt,name=login,proto3" json:"login,omitempty"`
	// UID is a user's UID.
	UID int32 `protobuf:"varint,3,opt,name=uid,proto3" json:"uid,omitempty"`
}

func (m *PersonSpec) Reset()         { *m = PersonSpec{} }
func (m *PersonSpec) String() string { return proto.CompactTextString(m) }
func (*PersonSpec) ProtoMessage()    {}

// RepoBuildInfo holds a repository build (if one exists for the originally
// specified revspec) and additional information. It is returned by
// Repos.GetRepoBuildInfo.
type RepoBuildInfo struct {
	Exact                *Build      `protobuf:"bytes,1,opt,name=exact" json:"exact,omitempty"`
	LastSuccessful       *Build      `protobuf:"bytes,2,opt,name=last_successful" json:"last_successful,omitempty"`
	CommitsBehind        int32       `protobuf:"varint,3,opt,name=commits_behind,proto3" json:"commits_behind,omitempty"`
	LastSuccessfulCommit *vcs.Commit `protobuf:"bytes,4,opt,name=last_successful_commit" json:"last_successful_commit,omitempty"`
}

func (m *RepoBuildInfo) Reset()         { *m = RepoBuildInfo{} }
func (m *RepoBuildInfo) String() string { return proto.CompactTextString(m) }
func (*RepoBuildInfo) ProtoMessage()    {}

type TaskSpec struct {
	BuildSpec `protobuf:"bytes,1,opt,name=build_spec,embedded=build_spec" json:"build_spec"`
	TaskID    int64 `protobuf:"varint,2,opt,name=task_id,proto3" json:"task_id,omitempty"`
}

func (m *TaskSpec) Reset()         { *m = TaskSpec{} }
func (m *TaskSpec) String() string { return proto.CompactTextString(m) }
func (*TaskSpec) ProtoMessage()    {}

// A TaskUpdate contains updated information to update on an existing task.
type TaskUpdate struct {
	StartedAt *pbtypes.Timestamp `protobuf:"bytes,1,opt,name=started_at" json:"started_at,omitempty"`
	EndedAt   *pbtypes.Timestamp `protobuf:"bytes,2,opt,name=ended_at" json:"ended_at,omitempty"`
	Success   bool               `protobuf:"varint,3,opt,name=success,proto3" json:"success,omitempty"`
	Failure   bool               `protobuf:"varint,4,opt,name=failure,proto3" json:"failure,omitempty"`
}

func (m *TaskUpdate) Reset()         { *m = TaskUpdate{} }
func (m *TaskUpdate) String() string { return proto.CompactTextString(m) }
func (*TaskUpdate) ProtoMessage()    {}

// User represents a registered user.
type User struct {
	// UID is the numeric primary key for a user.
	UID int32 `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	// Login is the user's username.
	Login string `protobuf:"bytes,2,opt,name=login,proto3" json:"login,omitempty"`
	// Domain is the host that the user originates from. If empty, it
	// is assumed to be the domain of the server.
	Domain string `protobuf:"bytes,3,opt,name=domain,proto3" json:"domain,omitempty"`
	// Name is the (possibly empty) full name of the user.
	Name string `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	// IsOrganization is whether this user represents an organization.
	IsOrganization bool `protobuf:"varint,5,opt,name=is_organization,proto3" json:"is_organization,omitempty"`
	// AvatarURL is the URL to an avatar image specified by the user.
	AvatarURL string `protobuf:"bytes,6,opt,name=avatar_url,proto3" json:"avatar_url,omitempty"`
	// Location is the user's physical location.
	Location string `protobuf:"bytes,7,opt,name=location,proto3" json:"location,omitempty"`
	// Company is the user's company.
	Company string `protobuf:"bytes,8,opt,name=company,proto3" json:"company,omitempty"`
	// HomepageURL is the user's homepage or blog URL.
	HomepageURL string `protobuf:"bytes,9,opt,name=homepage_url,proto3" json:"homepage_url,omitempty"`
	// Disabled is whether the user account is disabled.
	Disabled bool `protobuf:"varint,10,opt,name=disabled,proto3" json:"disabled,omitempty"`
	// Admin is whether the user is a site admin for the site named by
	// the Domain field.
	Admin bool `protobuf:"varint,12,opt,name=admin,proto3" json:"admin,omitempty"`
	// RegisteredAt is the date that the user registered. If the user has not
	// registered (i.e., we have processed their repos but they haven't signed into
	// Sourcegraph), it is null.
	RegisteredAt *pbtypes.Timestamp `protobuf:"bytes,11,opt,name=registered_at" json:"registered_at,omitempty"`
}

func (m *User) Reset()         { *m = User{} }
func (m *User) String() string { return proto.CompactTextString(m) }
func (*User) ProtoMessage()    {}

// UserSpec specifies a user. At least one of Login and UID must be
// nonempty.
type UserSpec struct {
	// Login is a user's login.
	Login string `protobuf:"bytes,1,opt,name=login,proto3" json:"login,omitempty"`
	// UID is a user's UID.
	UID int32 `protobuf:"varint,2,opt,name=uid,proto3" json:"uid,omitempty"`
	// Domain is the host that the user originates from. If empty, it
	// is assumed to be the domain of the server.
	Domain string `protobuf:"bytes,3,opt,name=domain,proto3" json:"domain,omitempty"`
}

func (m *UserSpec) Reset()         { *m = UserSpec{} }
func (m *UserSpec) String() string { return proto.CompactTextString(m) }
func (*UserSpec) ProtoMessage()    {}

// UsersListOptions specifies options for the UsersService.List method.
type UsersListOptions struct {
	// Query filters the results to only those whose logins match. The search algorithm
	// is an implementation detail (currently it is a prefix match).
	Query       string `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty" url:",omitempty"`
	Sort        string `protobuf:"bytes,2,opt,name=sort,proto3" json:"sort,omitempty" url:",omitempty"`
	Direction   string `protobuf:"bytes,3,opt,name=direction,proto3" json:"direction,omitempty" url:",omitempty"`
	ListOptions `protobuf:"bytes,4,opt,name=list_options,embedded=list_options" json:"list_options"`
}

func (m *UsersListOptions) Reset()         { *m = UsersListOptions{} }
func (m *UsersListOptions) String() string { return proto.CompactTextString(m) }
func (*UsersListOptions) ProtoMessage()    {}

type OrgsListOp struct {
	Member      UserSpec `protobuf:"bytes,1,opt,name=member" json:"member"`
	ListOptions `protobuf:"bytes,2,opt,name=list_options,embedded=list_options" json:"list_options"`
}

func (m *OrgsListOp) Reset()         { *m = OrgsListOp{} }
func (m *OrgsListOp) String() string { return proto.CompactTextString(m) }
func (*OrgsListOp) ProtoMessage()    {}

type EmailAddrList struct {
	EmailAddrs []*EmailAddr `protobuf:"bytes,1,rep,name=email_addrs" json:"email_addrs,omitempty"`
}

func (m *EmailAddrList) Reset()         { *m = EmailAddrList{} }
func (m *EmailAddrList) String() string { return proto.CompactTextString(m) }
func (*EmailAddrList) ProtoMessage()    {}

type OrgList struct {
	Orgs []*Org `protobuf:"bytes,1,rep,name=orgs" json:"orgs,omitempty"`
}

func (m *OrgList) Reset()         { *m = OrgList{} }
func (m *OrgList) String() string { return proto.CompactTextString(m) }
func (*OrgList) ProtoMessage()    {}

type PasswordResetToken struct {
	// token is the hard to guess token that allows a user to set a new password.
	Token string `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
}

func (m *PasswordResetToken) Reset()         { *m = PasswordResetToken{} }
func (m *PasswordResetToken) String() string { return proto.CompactTextString(m) }
func (*PasswordResetToken) ProtoMessage()    {}

type NewPassword struct {
	// password is the new password for the user who requested the password reset
	// token.
	Password string              `protobuf:"bytes,1,opt,name=password,proto3" json:"password,omitempty"`
	Token    *PasswordResetToken `protobuf:"bytes,2,opt,name=token" json:"token,omitempty"`
}

func (m *NewPassword) Reset()         { *m = NewPassword{} }
func (m *NewPassword) String() string { return proto.CompactTextString(m) }
func (*NewPassword) ProtoMessage()    {}

type NewAccount struct {
	// Login is the desired login for the new user account.
	Login string `protobuf:"bytes,1,opt,name=login,proto3" json:"login,omitempty"`
	// Email is the primary email address for the new user account.
	Email string `protobuf:"bytes,2,opt,name=email,proto3" json:"email,omitempty"`
	// Password is the password for the new user account.
	Password string `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
}

func (m *NewAccount) Reset()         { *m = NewAccount{} }
func (m *NewAccount) String() string { return proto.CompactTextString(m) }
func (*NewAccount) ProtoMessage()    {}

// AuthorizationCodeRequest: see
// https://tools.ietf.org/html/rfc6749#section-4.1.1.
type AuthorizationCodeRequest struct {
	ResponseType string   `protobuf:"bytes,1,opt,name=response_type,proto3" json:"response_type,omitempty"`
	ClientID     string   `protobuf:"bytes,2,opt,name=client_id,proto3" json:"client_id,omitempty"`
	RedirectURI  string   `protobuf:"bytes,3,opt,name=redirect_uri,proto3" json:"redirect_uri,omitempty"`
	Scope        []string `protobuf:"bytes,4,rep,name=scope" json:"scope,omitempty"`
	// UID is the UID of the user who will be presented with the code.
	UID int32 `protobuf:"varint,5,opt,name=uid,proto3" json:"uid,omitempty"`
}

func (m *AuthorizationCodeRequest) Reset()         { *m = AuthorizationCodeRequest{} }
func (m *AuthorizationCodeRequest) String() string { return proto.CompactTextString(m) }
func (*AuthorizationCodeRequest) ProtoMessage()    {}

// AuthorizationCode represents an access token request using the
// authorization_code OAuth2 grant type. See
// http://tools.ietf.org/html/rfc6749#section-4.1.3 for more
// information.
//
// The client_id field is not set in this message; it is taken from
// the authenticated client for the request (which must exist).
type AuthorizationCode struct {
	Code        string `protobuf:"bytes,1,opt,name=code,proto3" json:"code,omitempty"`
	RedirectURI string `protobuf:"bytes,2,opt,name=redirect_uri,proto3" json:"redirect_uri,omitempty"`
}

func (m *AuthorizationCode) Reset()         { *m = AuthorizationCode{} }
func (m *AuthorizationCode) String() string { return proto.CompactTextString(m) }
func (*AuthorizationCode) ProtoMessage()    {}

// LoginCredentials is the information a user submits to log in.
type LoginCredentials struct {
	// Login is the user's claimed login.
	Login string `protobuf:"bytes,1,opt,name=login,proto3" json:"login,omitempty"`
	// Password is the password (possibly) corresponding to the login.
	Password string `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
}

func (m *LoginCredentials) Reset()         { *m = LoginCredentials{} }
func (m *LoginCredentials) String() string { return proto.CompactTextString(m) }
func (*LoginCredentials) ProtoMessage()    {}

// BearerJWT is a Bearer JSON Web Token, which is used for client
// authentication during an authentication grant. See
// https://tools.ietf.org/html/draft-ietf-oauth-jwt-bearer-12#section-2.1
// for more information.
type BearerJWT struct {
	// Assertion is a JWT.
	Assertion string `protobuf:"bytes,1,opt,name=assertion,proto3" json:"assertion,omitempty"`
}

func (m *BearerJWT) Reset()         { *m = BearerJWT{} }
func (m *BearerJWT) String() string { return proto.CompactTextString(m) }
func (*BearerJWT) ProtoMessage()    {}

// AccessTokenRequest contains the information necessary to
// request an OAuth2 access token. It supports a subset of
// authorization grant types specified in
// http://tools.ietf.org/html/rfc6749#section-4.
type AccessTokenRequest struct {
	AuthorizationCode     *AuthorizationCode `protobuf:"bytes,1,opt,name=authorization_code" json:"authorization_code,omitempty"`
	ResourceOwnerPassword *LoginCredentials  `protobuf:"bytes,2,opt,name=resource_owner_password" json:"resource_owner_password,omitempty"`
	BearerJWT             *BearerJWT         `protobuf:"bytes,3,opt,name=bearer_jwt" json:"bearer_jwt,omitempty"`
	// TokenURL is the token endpoint URL on the OAuth2 authorization
	// server that the client is requesting an access token from.
	TokenURL string   `protobuf:"bytes,9,opt,name=token_url,proto3" json:"token_url,omitempty"`
	Scope    []string `protobuf:"bytes,17,rep,name=scope" json:"scope,omitempty"`
}

func (m *AccessTokenRequest) Reset()         { *m = AccessTokenRequest{} }
func (m *AccessTokenRequest) String() string { return proto.CompactTextString(m) }
func (*AccessTokenRequest) ProtoMessage()    {}

// AccessTokenResponse is a successful access token response. See
// http://tools.ietf.org/html/rfc6749#section-5.1 for more
// information.
type AccessTokenResponse struct {
	AccessToken  string   `protobuf:"bytes,1,opt,name=access_token,proto3" json:"access_token,omitempty"`
	TokenType    string   `protobuf:"bytes,2,opt,name=token_type,proto3" json:"token_type,omitempty"`
	ExpiresInSec int32    `protobuf:"varint,3,opt,name=expires_in_sec,proto3" json:"expires_in_sec,omitempty"`
	RefreshToken string   `protobuf:"bytes,4,opt,name=refresh_token,proto3" json:"refresh_token,omitempty"`
	Scope        []string `protobuf:"bytes,5,rep,name=scope" json:"scope,omitempty"`
}

func (m *AccessTokenResponse) Reset()         { *m = AccessTokenResponse{} }
func (m *AccessTokenResponse) String() string { return proto.CompactTextString(m) }
func (*AccessTokenResponse) ProtoMessage()    {}

// AuthInfo describes the currently authenticated client and/or user
// (if any).
type AuthInfo struct {
	// ClientID is the client ID of the currently authenticated
	// client. If a user is authenticated using an access token,
	// ClientID is the client ID of the registered client that the
	// access token was granted to.
	ClientID string `protobuf:"bytes,1,opt,name=client_id,proto3" json:"client_id,omitempty"`
	// UID is the UID of the currently authenticated user (if any).
	UID int32 `protobuf:"varint,2,opt,name=uid,proto3" json:"uid,omitempty"`
	// Domain is the domain of the currently authenticated user (if
	// any), or blank if the user account was registered on the
	// current server.
	Domain string `protobuf:"bytes,3,opt,name=domain,proto3" json:"domain,omitempty"`
}

func (m *AuthInfo) Reset()         { *m = AuthInfo{} }
func (m *AuthInfo) String() string { return proto.CompactTextString(m) }
func (*AuthInfo) ProtoMessage()    {}

type AuthorshipInfo struct {
	AuthorEmail    string            `protobuf:"bytes,1,opt,name=author_email,proto3" json:"author_email,omitempty"`
	LastCommitDate pbtypes.Timestamp `protobuf:"bytes,2,opt,name=last_commit_date" json:"last_commit_date"`
	// LastCommitID is the commit ID of the last commit that this author made to the
	// thing that this info describes.
	LastCommitID string `protobuf:"bytes,3,opt,name=last_commit_id,proto3" json:"last_commit_id,omitempty"`
}

func (m *AuthorshipInfo) Reset()         { *m = AuthorshipInfo{} }
func (m *AuthorshipInfo) String() string { return proto.CompactTextString(m) }
func (*AuthorshipInfo) ProtoMessage()    {}

// Completions holds search query completions.
type Completions struct {
	// TokenCompletions are suggested completions for the token at the raw query's
	// InsertionPoint.
	TokenCompletions []PBToken `protobuf:"bytes,1,rep,name=token_completions" json:"token_completions"`
	// ResolvedTokens is the resolution of the original query's tokens used to produce
	// the completions. It is useful for debugging.
	ResolvedTokens  []PBToken    `protobuf:"bytes,2,rep,name=resolved_tokens" json:"resolved_tokens"`
	ResolveErrors   []TokenError `protobuf:"bytes,3,rep,name=resolve_errors" json:"resolve_errors"`
	ResolutionFatal bool         `protobuf:"varint,4,opt,name=resolution_fatal,proto3" json:"resolution_fatal,omitempty"`
}

func (m *Completions) Reset()         { *m = Completions{} }
func (m *Completions) String() string { return proto.CompactTextString(m) }
func (*Completions) ProtoMessage()    {}

// Def is a code def returned by the Sourcegraph API.
type Def struct {
	graph.Def  `protobuf:"bytes,1,opt,name=def,embedded=def" json:""`
	DocHTML    *pbtypes2.HTML          `protobuf:"bytes,2,opt,name=doc_html" json:"doc_html,omitempty"`
	FmtStrings *graph.DefFormatStrings `protobuf:"bytes,3,opt,name=fmt_strings" json:"fmt_strings,omitempty"`
}

func (m *Def) Reset()         { *m = Def{} }
func (m *Def) String() string { return proto.CompactTextString(m) }
func (*Def) ProtoMessage()    {}

type DefAuthor struct {
	UID           int32  `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	Email         string `protobuf:"bytes,2,opt,name=email,proto3" json:"email,omitempty"`
	DefAuthorship `protobuf:"bytes,3,opt,name=def_authorship,embedded=def_authorship" json:"def_authorship"`
}

func (m *DefAuthor) Reset()         { *m = DefAuthor{} }
func (m *DefAuthor) String() string { return proto.CompactTextString(m) }
func (*DefAuthor) ProtoMessage()    {}

type DefAuthorship struct {
	AuthorshipInfo `protobuf:"bytes,1,opt,name=authorship_info,embedded=authorship_info" json:"authorship_info"`
	// Exported is whether the def is exported.
	Exported        bool    `protobuf:"varint,2,opt,name=exported,proto3" json:"exported,omitempty"`
	Bytes           int32   `protobuf:"varint,3,opt,name=bytes,proto3" json:"bytes,omitempty"`
	BytesProportion float64 `protobuf:"fixed64,4,opt,name=bytes_proportion,proto3" json:"bytes_proportion,omitempty"`
}

func (m *DefAuthorship) Reset()         { *m = DefAuthorship{} }
func (m *DefAuthorship) String() string { return proto.CompactTextString(m) }
func (*DefAuthorship) ProtoMessage()    {}

type DefClient struct {
	UID            int32  `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	Email          string `protobuf:"bytes,2,opt,name=email,proto3" json:"email,omitempty"`
	AuthorshipInfo `protobuf:"bytes,3,opt,name=authorship_info,embedded=authorship_info" json:"authorship_info"`
	// UseCount is the number of times this person referred to the def.
	UseCount int32 `protobuf:"varint,4,opt,name=use_count,proto3" json:"use_count,omitempty"`
}

func (m *DefClient) Reset()         { *m = DefClient{} }
func (m *DefClient) String() string { return proto.CompactTextString(m) }
func (*DefClient) ProtoMessage()    {}

// A DefDelta represents a single definition that was changed. It has fields for
// the before (Base) and after (Head) versions. If both Base and Head are non-nil,
// then the def was changed from base to head. Otherwise, one of the fields being
// nil means that the def did not exist in that revision (e.g., it was added or
// deleted from base to head).
type DefDelta struct {
	// the def in the base commit (if nil, this def was added in the head)
	Base *Def `protobuf:"bytes,1,opt,name=base" json:"base,omitempty"`
	// the def in the head commit (if nil, this def was deleted in the head)
	Head *Def `protobuf:"bytes,2,opt,name=head" json:"head,omitempty"`
}

func (m *DefDelta) Reset()         { *m = DefDelta{} }
func (m *DefDelta) String() string { return proto.CompactTextString(m) }
func (*DefDelta) ProtoMessage()    {}

// DefGetOptions specifies options for DefsService.Get.
type DefGetOptions struct {
	Doc bool `protobuf:"varint,1,opt,name=doc,proto3" json:"doc,omitempty" url:",omitempty"`
}

func (m *DefGetOptions) Reset()         { *m = DefGetOptions{} }
func (m *DefGetOptions) String() string { return proto.CompactTextString(m) }
func (*DefGetOptions) ProtoMessage()    {}

// DefListAuthorsOptions specifies options for DefsService.ListAuthors.
type DefListAuthorsOptions struct {
	ListOptions `protobuf:"bytes,1,opt,name=list_options,embedded=list_options" json:"list_options"`
}

func (m *DefListAuthorsOptions) Reset()         { *m = DefListAuthorsOptions{} }
func (m *DefListAuthorsOptions) String() string { return proto.CompactTextString(m) }
func (*DefListAuthorsOptions) ProtoMessage()    {}

// DefListClientsOptions specifies options for DefsService.ListClients.
type DefListClientsOptions struct {
	ListOptions `protobuf:"bytes,1,opt,name=list_options,embedded=list_options" json:"list_options"`
}

func (m *DefListClientsOptions) Reset()         { *m = DefListClientsOptions{} }
func (m *DefListClientsOptions) String() string { return proto.CompactTextString(m) }
func (*DefListClientsOptions) ProtoMessage()    {}

// DefListExamplesOptions specifies options for DefsService.ListExamples.
type DefListExamplesOptions struct {
	Formatted bool `protobuf:"varint,1,opt,name=formatted,proto3" json:"formatted,omitempty" url:",omitempty"`
	// Filter by a specific Repo URI
	Repo string `protobuf:"bytes,2,opt,name=repo,proto3" json:"repo,omitempty" url:",omitempty"`
	// TokenizedSource requests that the source code be returned as a tokenized data
	// structure rather than an (annotated) string.
	//
	// This is useful when the client wants to take full control of rendering and
	// manipulating the contents.
	TokenizedSource bool `protobuf:"varint,3,opt,name=tokenized_source,proto3" json:"tokenized_source,omitempty" url:",omitempty"`
	ListOptions     `protobuf:"bytes,4,opt,name=list_options,embedded=list_options" json:"list_options"`
}

func (m *DefListExamplesOptions) Reset()         { *m = DefListExamplesOptions{} }
func (m *DefListExamplesOptions) String() string { return proto.CompactTextString(m) }
func (*DefListExamplesOptions) ProtoMessage()    {}

// DefListOptions specifies options for DefsService.List.
type DefListOptions struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty" url:",omitempty"`
	// Specifies a search query for defs. If specified, then the Sort and Direction
	// options are ignored
	Query string `protobuf:"bytes,2,opt,name=query,proto3" json:"query,omitempty" url:",omitempty"`
	// ByteStart and ByteEnd will restrict the results to only definitions that overlap
	// with the specified start and end byte offsets. This filter is only applied if
	// both values are set.
	ByteStart uint32 `protobuf:"varint,3,opt,name=byte_start,proto3" json:"byte_start,omitempty"`
	// ByteStart and ByteEnd will restrict the results to only definitions that overlap
	// with the specified start and end byte offsets. This filter is only applied if
	// both values are set.
	ByteEnd uint32 `protobuf:"varint,4,opt,name=byte_end,proto3" json:"byte_end,omitempty"`
	// DefKeys, if set, will return the definitions that match the given DefKey
	DefKeys []*graph.DefKey `protobuf:"bytes,5,rep,name=def_keys" json:"def_keys,omitempty"`
	// RepoRevs constrains the results to a set of repository revisions (given by their
	// URIs plus an optional "@" and a revision specifier). For example,
	// "repo.com/foo@revspec".
	RepoRevs []string `protobuf:"bytes,6,rep,name=repo_revs" json:"repo_revs,omitempty" url:",omitempty,comma"`
	UnitType string   `protobuf:"bytes,7,opt,name=unit_type,proto3" json:"unit_type,omitempty" url:",omitempty"`
	Unit     string   `protobuf:"bytes,8,opt,name=unit,proto3" json:"unit,omitempty" url:",omitempty"`
	Path     string   `protobuf:"bytes,9,opt,name=path,proto3" json:"path,omitempty" url:",omitempty"`
	// File, if specified, will restrict the results to only defs defined in the
	// specified file.
	File string `protobuf:"bytes,10,opt,name=file,proto3" json:"file,omitempty" url:",omitempty"`
	// FilePathPrefix, if specified, will restrict the results to only defs defined in
	// files whose path is underneath the specified prefix.
	FilePathPrefix string   `protobuf:"bytes,11,opt,name=file_path_prefix,proto3" json:"file_path_prefix,omitempty" url:",omitempty"`
	Kinds          []string `protobuf:"bytes,12,rep,name=kinds" json:"kinds,omitempty" url:",omitempty,comma"`
	Exported       bool     `protobuf:"varint,13,opt,name=exported,proto3" json:"exported,omitempty" url:",omitempty"`
	Nonlocal       bool     `protobuf:"varint,14,opt,name=nonlocal,proto3" json:"nonlocal,omitempty" url:",omitempty"`
	// IncludeTest is whether the results should include definitions in test files.
	IncludeTest bool `protobuf:"varint,15,opt,name=include_test,proto3" json:"include_test,omitempty" url:",omitempty"`
	// Enhancements
	Doc   bool `protobuf:"varint,16,opt,name=doc,proto3" json:"doc,omitempty" url:",omitempty"`
	Fuzzy bool `protobuf:"varint,17,opt,name=fuzzy,proto3" json:"fuzzy,omitempty" url:",omitempty"`
	// Sorting
	Sort      string `protobuf:"bytes,18,opt,name=sort,proto3" json:"sort,omitempty" url:",omitempty"`
	Direction string `protobuf:"bytes,19,opt,name=direction,proto3" json:"direction,omitempty" url:",omitempty"`
	// Paging
	ListOptions `protobuf:"bytes,20,opt,name=list_options,embedded=list_options" json:"list_options"`
}

func (m *DefListOptions) Reset()         { *m = DefListOptions{} }
func (m *DefListOptions) String() string { return proto.CompactTextString(m) }
func (*DefListOptions) ProtoMessage()    {}

type DefListRefsOptions struct {
	Authorship  bool   `protobuf:"varint,1,opt,name=authorship,proto3" json:"authorship,omitempty" url:",omitempty"`
	Repo        string `protobuf:"bytes,2,opt,name=repo,proto3" json:"repo,omitempty" url:",omitempty"`
	ListOptions `protobuf:"bytes,3,opt,name=list_options,embedded=list_options" json:"list_options"`
}

func (m *DefListRefsOptions) Reset()         { *m = DefListRefsOptions{} }
func (m *DefListRefsOptions) String() string { return proto.CompactTextString(m) }
func (*DefListRefsOptions) ProtoMessage()    {}

// DefSpec specifies a def.
type DefSpec struct {
	Repo     string `protobuf:"bytes,1,opt,name=repo,proto3" json:"repo,omitempty"`
	CommitID string `protobuf:"bytes,2,opt,name=commit_id,proto3" json:"commit_id,omitempty"`
	UnitType string `protobuf:"bytes,3,opt,name=unit_type,proto3" json:"unit_type,omitempty"`
	Unit     string `protobuf:"bytes,4,opt,name=unit,proto3" json:"unit,omitempty"`
	Path     string `protobuf:"bytes,5,opt,name=path,proto3" json:"path,omitempty"`
}

func (m *DefSpec) Reset()         { *m = DefSpec{} }
func (m *DefSpec) String() string { return proto.CompactTextString(m) }
func (*DefSpec) ProtoMessage()    {}

type DefsGetOp struct {
	Def DefSpec        `protobuf:"bytes,1,opt,name=def" json:"def"`
	Opt *DefGetOptions `protobuf:"bytes,2,opt,name=opt" json:"opt,omitempty"`
}

func (m *DefsGetOp) Reset()         { *m = DefsGetOp{} }
func (m *DefsGetOp) String() string { return proto.CompactTextString(m) }
func (*DefsGetOp) ProtoMessage()    {}

type DefList struct {
	Defs []*Def `protobuf:"bytes,1,rep,name=defs" json:"defs,omitempty"`
}

func (m *DefList) Reset()         { *m = DefList{} }
func (m *DefList) String() string { return proto.CompactTextString(m) }
func (*DefList) ProtoMessage()    {}

type DefsListRefsOp struct {
	Def DefSpec             `protobuf:"bytes,1,opt,name=def" json:"def"`
	Opt *DefListRefsOptions `protobuf:"bytes,2,opt,name=opt" json:"opt,omitempty"`
}

func (m *DefsListRefsOp) Reset()         { *m = DefsListRefsOp{} }
func (m *DefsListRefsOp) String() string { return proto.CompactTextString(m) }
func (*DefsListRefsOp) ProtoMessage()    {}

type RefList struct {
	Refs         []*Ref `protobuf:"bytes,1,rep,name=refs" json:"refs,omitempty"`
	ListResponse `protobuf:"bytes,2,opt,name=list_response,embedded=list_response" json:"list_response"`
}

func (m *RefList) Reset()         { *m = RefList{} }
func (m *RefList) String() string { return proto.CompactTextString(m) }
func (*RefList) ProtoMessage()    {}

type DefsListExamplesOp struct {
	Def DefSpec `protobuf:"bytes,1,opt,name=def" json:"def"`
	// If set, source code in the examples will be linked to this branch, rather
	// than to the commit ID.
	Rev string                  `protobuf:"bytes,2,opt,name=rev,proto3" json:"rev,omitempty"`
	Opt *DefListExamplesOptions `protobuf:"bytes,3,opt,name=opt" json:"opt,omitempty"`
}

func (m *DefsListExamplesOp) Reset()         { *m = DefsListExamplesOp{} }
func (m *DefsListExamplesOp) String() string { return proto.CompactTextString(m) }
func (*DefsListExamplesOp) ProtoMessage()    {}

type ExampleList struct {
	Examples     []*Example `protobuf:"bytes,1,rep,name=examples" json:"examples,omitempty"`
	ListResponse `protobuf:"bytes,2,opt,name=list_response,embedded=list_response" json:"list_response"`
}

func (m *ExampleList) Reset()         { *m = ExampleList{} }
func (m *ExampleList) String() string { return proto.CompactTextString(m) }
func (*ExampleList) ProtoMessage()    {}

type DefsListAuthorsOp struct {
	Def DefSpec                `protobuf:"bytes,1,opt,name=def" json:"def"`
	Opt *DefListAuthorsOptions `protobuf:"bytes,2,opt,name=opt" json:"opt,omitempty"`
}

func (m *DefsListAuthorsOp) Reset()         { *m = DefsListAuthorsOp{} }
func (m *DefsListAuthorsOp) String() string { return proto.CompactTextString(m) }
func (*DefsListAuthorsOp) ProtoMessage()    {}

type DefsListClientsOp struct {
	Def DefSpec                `protobuf:"bytes,1,opt,name=def" json:"def"`
	Opt *DefListClientsOptions `protobuf:"bytes,2,opt,name=opt" json:"opt,omitempty"`
}

func (m *DefsListClientsOp) Reset()         { *m = DefsListClientsOp{} }
func (m *DefsListClientsOp) String() string { return proto.CompactTextString(m) }
func (*DefsListClientsOp) ProtoMessage()    {}

// Delta represents the difference between two commits (possibly in 2 separate
// repositories).
type Delta struct {
	Base       RepoRevSpec `protobuf:"bytes,1,opt,name=base" json:"base"`
	Head       RepoRevSpec `protobuf:"bytes,2,opt,name=head" json:"head"`
	BaseCommit *vcs.Commit `protobuf:"bytes,3,opt,name=base_commit" json:"base_commit,omitempty"`
	HeadCommit *vcs.Commit `protobuf:"bytes,4,opt,name=head_commit" json:"head_commit,omitempty"`
	BaseRepo   *Repo       `protobuf:"bytes,5,opt,name=base_repo" json:"base_repo,omitempty"`
	HeadRepo   *Repo       `protobuf:"bytes,6,opt,name=head_repo" json:"head_repo,omitempty"`
	BaseBuild  *Build      `protobuf:"bytes,7,opt,name=base_build" json:"base_build,omitempty"`
	HeadBuild  *Build      `protobuf:"bytes,8,opt,name=head_build" json:"head_build,omitempty"`
}

func (m *Delta) Reset()         { *m = Delta{} }
func (m *Delta) String() string { return proto.CompactTextString(m) }
func (*Delta) ProtoMessage()    {}

// DeltaAffectedPerson describes a person (registered user or committer email
// address) that is affected by a delta. It includes fields for the person affected
// as well as the defs that are the reason why we consider them to be affected.
//
// The person's relationship to the Defs depends on what method returned this
// DeltaAffectedPerson. If it was returned by a method that lists authors, then the
// Defs are definitions that the Person committed. If it was returned by a method
// that lists clients (a.k.a users), then the Defs are definitions that the Person
// uses.
type DeltaAffectedPerson struct {
	// the affected person
	Person `protobuf:"bytes,1,opt,name=person,embedded=person" json:"person"`
	// the defs they authored or use (the reason why they're affected)
	Defs []*Def `protobuf:"bytes,2,rep,name=defs" json:"defs,omitempty"`
}

func (m *DeltaAffectedPerson) Reset()         { *m = DeltaAffectedPerson{} }
func (m *DeltaAffectedPerson) String() string { return proto.CompactTextString(m) }
func (*DeltaAffectedPerson) ProtoMessage()    {}

// DeltaDefs describes definitions added/changed/deleted in a delta.
type DeltaDefs struct {
	// added/changed/deleted defs
	Defs []*DefDelta `protobuf:"bytes,1,rep,name=defs" json:"defs,omitempty"`
	// overall diffstat (not subject to pagination)
	DiffStat diff.Stat `protobuf:"bytes,2,opt,name=diff_stat" json:"diff_stat"`
}

func (m *DeltaDefs) Reset()         { *m = DeltaDefs{} }
func (m *DeltaDefs) String() string { return proto.CompactTextString(m) }
func (*DeltaDefs) ProtoMessage()    {}

// FileDiff holds data about a diff, and additionally stores extended
// information about its hunks.
type FileDiff struct {
	diff.FileDiff `protobuf:"bytes,1,opt,name=file_diff,embedded=file_diff" json:"file_diff"`
	Hunks         []*Hunk `protobuf:"bytes,2,rep,name=hunks" json:"hunks,omitempty"`
	// PreImage is the CommitID at which this file was before the change occurred.
	PreImage string `protobuf:"bytes,3,opt,name=pre_image,proto3" json:",omitempty"`
	// PostImage is the CommitID at which this file was after the change occurred.
	PostImage string `protobuf:"bytes,4,opt,name=post_image,proto3" json:",omitempty"`
	// Stat contains statistics about additions and deletions to this diff.
	Stats diff.Stat `protobuf:"bytes,5,opt,name=stats" json:"stats"`
}

func (m *FileDiff) Reset()         { *m = FileDiff{} }
func (m *FileDiff) String() string { return proto.CompactTextString(m) }
func (*FileDiff) ProtoMessage()    {}

// Hunk holds data about a hunk in a diff.
type Hunk struct {
	diff.Hunk `protobuf:"bytes,1,opt,name=hunk,embedded=hunk" json:"hunk"`
	// LinePrefixes holds a string where each character's index corresponds
	// to a line in the BodySource, and its value reflects whether the line
	// is an addition, deletion, or change ('+', '-', ' ').
	LinePrefixes string `protobuf:"bytes,2,opt,name=line_prefixes,proto3" json:"line_prefixes,omitempty"`
	// BaseSource holds the source code for the original hunk, having all
	// lines starting from the original line down to the end of the hunk.
	BaseSource *SourceCode `protobuf:"bytes,3,opt,name=base_source" json:"base_source,omitempty"`
	// HeadSource contains the source code for the new hunk, holding
	// all consecutive lines from the start to the end.
	HeadSource *SourceCode `protobuf:"bytes,4,opt,name=head_source" json:"head_source,omitempty"`
	// BodySource contains the source code for the Hunk body and is a mix
	// of both additions and deletions.
	BodySource *SourceCode `protobuf:"bytes,5,opt,name=body_source" json:"body_source,omitempty"`
}

func (m *Hunk) Reset()         { *m = Hunk{} }
func (m *Hunk) String() string { return proto.CompactTextString(m) }
func (*Hunk) ProtoMessage()    {}

// DeltaFiles describes files added/changed/deleted in a delta.
type DeltaFiles struct {
	FileDiffs []*FileDiff `protobuf:"bytes,1,rep,name=file_diffs" json:"file_diffs,omitempty"`
	Delta     *Delta      `protobuf:"bytes,2,opt,name=delta" json:"delta,omitempty"`
	Stats     diff.Stat   `protobuf:"bytes,3,opt,name=stats" json:"stats"`
	// OverThreshold will be true when the source code contents of the diff
	// have not been tokenized and linked. This occurs when the 'MaxSize'
	// limit in DeltaListFilesOptions has been met.
	OverThreshold bool `protobuf:"varint,4,opt,name=over_threshold,proto3" json:"over_threshold,omitempty"`
}

func (m *DeltaFiles) Reset()         { *m = DeltaFiles{} }
func (m *DeltaFiles) String() string { return proto.CompactTextString(m) }
func (*DeltaFiles) ProtoMessage()    {}

// DeltaFilter specifies criteria by which to filter results from DeltaListXxx
// methods.
type DeltaFilter struct {
	Unit     string `protobuf:"bytes,1,opt,name=unit,proto3" json:"unit,omitempty" url:",omitempty"`
	UnitType string `protobuf:"bytes,2,opt,name=unit_type,proto3" json:"unit_type,omitempty" url:",omitempty"`
}

func (m *DeltaFilter) Reset()         { *m = DeltaFilter{} }
func (m *DeltaFilter) String() string { return proto.CompactTextString(m) }
func (*DeltaFilter) ProtoMessage()    {}

// DeltaListAffectedAuthorsOptions specifies options for ListAffectedAuthors.
type DeltaListAffectedAuthorsOptions struct {
	DeltaFilter `protobuf:"bytes,1,opt,name=delta_filter,embedded=delta_filter" json:"delta_filter"`
	ListOptions `protobuf:"bytes,2,opt,name=list_options,embedded=list_options" json:"list_options"`
}

func (m *DeltaListAffectedAuthorsOptions) Reset()         { *m = DeltaListAffectedAuthorsOptions{} }
func (m *DeltaListAffectedAuthorsOptions) String() string { return proto.CompactTextString(m) }
func (*DeltaListAffectedAuthorsOptions) ProtoMessage()    {}

// DeltaListAffectedClientsOptions specifies options for ListAffectedClients.
type DeltaListAffectedClientsOptions struct {
	DeltaFilter `protobuf:"bytes,1,opt,name=delta_filter,embedded=delta_filter" json:"delta_filter"`
	ListOptions `protobuf:"bytes,2,opt,name=list_options,embedded=list_options" json:"list_options"`
}

func (m *DeltaListAffectedClientsOptions) Reset()         { *m = DeltaListAffectedClientsOptions{} }
func (m *DeltaListAffectedClientsOptions) String() string { return proto.CompactTextString(m) }
func (*DeltaListAffectedClientsOptions) ProtoMessage()    {}

// DeltaListDefsOptions specifies options for ListDefs.
type DeltaListDefsOptions struct {
	DeltaFilter `protobuf:"bytes,1,opt,name=delta_filter,embedded=delta_filter" json:"delta_filter"`
	ListOptions `protobuf:"bytes,2,opt,name=list_options,embedded=list_options" json:"list_options"`
}

func (m *DeltaListDefsOptions) Reset()         { *m = DeltaListDefsOptions{} }
func (m *DeltaListDefsOptions) String() string { return proto.CompactTextString(m) }
func (*DeltaListDefsOptions) ProtoMessage()    {}

// DeltaListFilesOptions specifies options for ListFiles.
type DeltaListFilesOptions struct {
	// Formatted is whether the files should have their contents code-formatted
	// (syntax-highlighted and reference-linked) if they contain code.
	Formatted bool `protobuf:"varint,1,opt,name=formatted,proto3" json:"formatted,omitempty" url:",omitempty"`
	// Filter filters the list of returned files to those whose name matches Filter.
	Filter string `protobuf:"bytes,2,opt,name=filter,proto3" json:"filter,omitempty" url:",omitempty"`
	// Tokenized, when set, will tokenize the whole source code
	// contained in the diff, returning 3 versions for each hunk: Head
	// revision, Base revision and Hunk body. For more information,
	// see sourcegraph.Hunk.
	Tokenized bool `protobuf:"varint,3,opt,name=tokenized,proto3" json:"tokenized,omitempty" url:",omitempty"`
	// MaxSize stores the maximum number of bytes that will be accepted for tokenizing
	// the diff. If the size of the diff exceeds this value, the returned structure
	// will not contain the linked and tokenized source code.
	// This option is useful when one wishes to present the data in a browser and it
	// may be too large for that. DeltaFiles structure size can be up to 4 times the
	// size of the raw diff when tokenized and linked.
	MaxSize     int32 `protobuf:"varint,4,opt,name=max_size,proto3" json:"max_size,omitempty" url:",omitempty"`
	DeltaFilter `protobuf:"bytes,5,opt,name=delta_filter,embedded=delta_filter" json:"delta_filter"`
}

func (m *DeltaListFilesOptions) Reset()         { *m = DeltaListFilesOptions{} }
func (m *DeltaListFilesOptions) String() string { return proto.CompactTextString(m) }
func (*DeltaListFilesOptions) ProtoMessage()    {}

// DeltaListUnitsOptions specifies options for ListUnits.
type DeltaListUnitsOptions struct {
}

func (m *DeltaListUnitsOptions) Reset()         { *m = DeltaListUnitsOptions{} }
func (m *DeltaListUnitsOptions) String() string { return proto.CompactTextString(m) }
func (*DeltaListUnitsOptions) ProtoMessage()    {}

// A DeltaSpec specifies a delta.
type DeltaSpec struct {
	Base RepoRevSpec `protobuf:"bytes,1,opt,name=base" json:"base"`
	Head RepoRevSpec `protobuf:"bytes,2,opt,name=head" json:"head"`
}

func (m *DeltaSpec) Reset()         { *m = DeltaSpec{} }
func (m *DeltaSpec) String() string { return proto.CompactTextString(m) }
func (*DeltaSpec) ProtoMessage()    {}

type DeltasListUnitsOp struct {
	Ds  DeltaSpec              `protobuf:"bytes,1,opt,name=ds" json:"ds"`
	Opt *DeltaListUnitsOptions `protobuf:"bytes,2,opt,name=opt" json:"opt,omitempty"`
}

func (m *DeltasListUnitsOp) Reset()         { *m = DeltasListUnitsOp{} }
func (m *DeltasListUnitsOp) String() string { return proto.CompactTextString(m) }
func (*DeltasListUnitsOp) ProtoMessage()    {}

type UnitDeltaList struct {
	UnitDeltas []*UnitDelta `protobuf:"bytes,1,rep,name=unit_deltas" json:"unit_deltas,omitempty"`
}

func (m *UnitDeltaList) Reset()         { *m = UnitDeltaList{} }
func (m *UnitDeltaList) String() string { return proto.CompactTextString(m) }
func (*UnitDeltaList) ProtoMessage()    {}

type DeltasListDefsOp struct {
	Ds  DeltaSpec             `protobuf:"bytes,1,opt,name=ds" json:"ds"`
	Opt *DeltaListDefsOptions `protobuf:"bytes,2,opt,name=opt" json:"opt,omitempty"`
}

func (m *DeltasListDefsOp) Reset()         { *m = DeltasListDefsOp{} }
func (m *DeltasListDefsOp) String() string { return proto.CompactTextString(m) }
func (*DeltasListDefsOp) ProtoMessage()    {}

type DeltasListFilesOp struct {
	Ds  DeltaSpec              `protobuf:"bytes,1,opt,name=ds" json:"ds"`
	Opt *DeltaListFilesOptions `protobuf:"bytes,2,opt,name=opt" json:"opt,omitempty"`
}

func (m *DeltasListFilesOp) Reset()         { *m = DeltasListFilesOp{} }
func (m *DeltasListFilesOp) String() string { return proto.CompactTextString(m) }
func (*DeltasListFilesOp) ProtoMessage()    {}

type DeltasListAffectedAuthorsOp struct {
	Ds  DeltaSpec                        `protobuf:"bytes,1,opt,name=ds" json:"ds"`
	Opt *DeltaListAffectedAuthorsOptions `protobuf:"bytes,2,opt,name=opt" json:"opt,omitempty"`
}

func (m *DeltasListAffectedAuthorsOp) Reset()         { *m = DeltasListAffectedAuthorsOp{} }
func (m *DeltasListAffectedAuthorsOp) String() string { return proto.CompactTextString(m) }
func (*DeltasListAffectedAuthorsOp) ProtoMessage()    {}

type DeltaAffectedPersonList struct {
	DeltaAffectedPersons []*DeltaAffectedPerson `protobuf:"bytes,1,rep,name=delta_affected_persons" json:"delta_affected_persons,omitempty"`
}

func (m *DeltaAffectedPersonList) Reset()         { *m = DeltaAffectedPersonList{} }
func (m *DeltaAffectedPersonList) String() string { return proto.CompactTextString(m) }
func (*DeltaAffectedPersonList) ProtoMessage()    {}

type DeltasListAffectedClientsOp struct {
	Ds  DeltaSpec                        `protobuf:"bytes,1,opt,name=ds" json:"ds"`
	Opt *DeltaListAffectedClientsOptions `protobuf:"bytes,2,opt,name=opt" json:"opt,omitempty"`
}

func (m *DeltasListAffectedClientsOp) Reset()         { *m = DeltasListAffectedClientsOp{} }
func (m *DeltasListAffectedClientsOp) String() string { return proto.CompactTextString(m) }
func (*DeltasListAffectedClientsOp) ProtoMessage()    {}

// Example is a usage example of a def.
type Example struct {
	graph1.Ref `protobuf:"bytes,1,opt,name=ref,embedded=ref" json:""`
	// SrcHTML is the formatted HTML source code of the example, with links to
	// definitions.
	SrcHTML string `protobuf:"bytes,2,opt,name=src_html,proto3" json:"src_html,omitempty"`
	// SourceCode contains the parsed source for this example, if requested via
	// DefListExamplesOptions.
	SourceCode *SourceCode `protobuf:"bytes,3,opt,name=source_code" json:"source_code,omitempty"`
	// The line that the given example starts on
	StartLine int32 `protobuf:"varint,4,opt,name=start_line,proto3" json:"start_line,omitempty"`
	// The line that the given example ends on
	EndLine int32 `protobuf:"varint,5,opt,name=end_line,proto3" json:"end_line,omitempty"`
	// Error is whether an error occurred while fetching this example.
	Error bool `protobuf:"varint,6,opt,name=error,proto3" json:"error,omitempty"`
	// If the example has been requested by revision name (ie. branch, tag), this
	// value will be set.
	Rev string `protobuf:"bytes,7,opt,name=rev,proto3" json:",omitempty"`
}

func (m *Example) Reset()         { *m = Example{} }
func (m *Example) String() string { return proto.CompactTextString(m) }
func (*Example) ProtoMessage()    {}

// FormatResult contains information about and warnings from the formatting
// operation (if Formatted is true in the options).
type FormatResult struct {
	// TooManyRefs indicates that the file being formatted exceeded the maximum number
	// of refs that are linked. Only the first NumRefs refs are linked.
	TooManyRefs bool `protobuf:"varint,1,opt,name=too_many_refs,proto3" json:"too_many_refs,omitempty"`
	// NumRefs is the number of refs that were linked in this file. If the total number
	// of refs in the file exceeds the (server-defined) limit, NumRefs is capped at the
	// limit.
	NumRefs int32 `protobuf:"varint,2,opt,name=num_refs,proto3" json:"num_refs,omitempty"`
	// LineStartByteOffsets is the byte offset of each line's first byte.
	LineStartByteOffsets []int32 `protobuf:"varint,3,rep,name=line_start_byte_offsets" json:"line_start_byte_offsets,omitempty"`
}

func (m *FormatResult) Reset()         { *m = FormatResult{} }
func (m *FormatResult) String() string { return proto.CompactTextString(m) }
func (*FormatResult) ProtoMessage()    {}

type MarkdownData struct {
	Rendered  []byte     `protobuf:"bytes,1,opt,name=rendered,proto3" json:"rendered,omitempty"`
	Checklist *Checklist `protobuf:"bytes,2,opt,name=checklist" json:"checklist,omitempty"`
}

func (m *MarkdownData) Reset()         { *m = MarkdownData{} }
func (m *MarkdownData) String() string { return proto.CompactTextString(m) }
func (*MarkdownData) ProtoMessage()    {}

type MarkdownOpt struct {
	EnableCheckboxes bool `protobuf:"varint,1,opt,name=enable_checkboxes,proto3" json:"enable_checkboxes,omitempty"`
}

func (m *MarkdownOpt) Reset()         { *m = MarkdownOpt{} }
func (m *MarkdownOpt) String() string { return proto.CompactTextString(m) }
func (*MarkdownOpt) ProtoMessage()    {}

type MarkdownRequestBody struct {
	Markdown    []byte `protobuf:"bytes,1,opt,name=markdown,proto3" json:"markdown,omitempty"`
	MarkdownOpt `protobuf:"bytes,2,opt,name=markdown_opt,embedded=markdown_opt" json:"markdown_opt"`
}

func (m *MarkdownRequestBody) Reset()         { *m = MarkdownRequestBody{} }
func (m *MarkdownRequestBody) String() string { return proto.CompactTextString(m) }
func (*MarkdownRequestBody) ProtoMessage()    {}

type MarkdownRenderOp struct {
	Markdown []byte      `protobuf:"bytes,1,opt,name=markdown,proto3" json:"markdown,omitempty"`
	Opt      MarkdownOpt `protobuf:"bytes,2,opt,name=opt" json:"opt"`
}

func (m *MarkdownRenderOp) Reset()         { *m = MarkdownRenderOp{} }
func (m *MarkdownRenderOp) String() string { return proto.CompactTextString(m) }
func (*MarkdownRenderOp) ProtoMessage()    {}

type Ref struct {
	graph1.Ref `protobuf:"bytes,1,opt,name=ref,embedded=ref" json:""`
	Authorship *AuthorshipInfo `protobuf:"bytes,2,opt,name=authorship" json:"authorship,omitempty"`
}

func (m *Ref) Reset()         { *m = Ref{} }
func (m *Ref) String() string { return proto.CompactTextString(m) }
func (*Ref) ProtoMessage()    {}

// RepoTreeGetOptions specifies options for (RepoTreeService).Get.
type RepoTreeGetOptions struct {
	// Formatted is whether the specified entry, if it's a file, should have its
	// Contents code-formatted using HTML.
	Formatted bool `protobuf:"varint,1,opt,name=formatted,proto3" json:"formatted,omitempty"`
	// HighlightStrings is a list of fixed strings that should be wrapped in a <span
	// class="highlight"> in the returned HTML. It only takes effect if Formatted is
	// true.
	HighlightStrings []string `protobuf:"bytes,2,rep,name=highlight_strings" json:"highlight_strings,omitempty"`
	// TokenizedSource requests that the source code be returned as a tokenized data
	// structure rather than an (annotated) string.
	//
	// This is useful when the client wants to take full control of rendering and
	// manipulating the contents.
	TokenizedSource          bool `protobuf:"varint,3,opt,name=tokenized_source,proto3" json:"tokenized_source,omitempty" url:",omitempty"`
	ContentsAsString         bool `protobuf:"varint,4,opt,name=contents_as_string,proto3" json:"contents_as_string,omitempty" url:",omitempty"`
	vcsclient.GetFileOptions `protobuf:"bytes,5,opt,name=get_file_options,embedded=get_file_options" json:"get_file_options"`
}

func (m *RepoTreeGetOptions) Reset()         { *m = RepoTreeGetOptions{} }
func (m *RepoTreeGetOptions) String() string { return proto.CompactTextString(m) }
func (*RepoTreeGetOptions) ProtoMessage()    {}

type RepoTreeSearchOptions struct {
	vcs.SearchOptions `protobuf:"bytes,1,opt,name=search_options,embedded=search_options" json:"search_options"`
	Formatted         bool `protobuf:"varint,2,opt,name=formatted,proto3" json:"formatted,omitempty"`
}

func (m *RepoTreeSearchOptions) Reset()         { *m = RepoTreeSearchOptions{} }
func (m *RepoTreeSearchOptions) String() string { return proto.CompactTextString(m) }
func (*RepoTreeSearchOptions) ProtoMessage()    {}

// A RepoTreeSearchResult is a tree search result that includes the repo and rev it
// came from.
type RepoTreeSearchResult struct {
	vcs.SearchResult `protobuf:"bytes,1,opt,name=search_result,embedded=search_result" json:"search_result"`
	RepoRev          RepoRevSpec `protobuf:"bytes,2,opt,name=repo_rev" json:"repo_rev"`
}

func (m *RepoTreeSearchResult) Reset()         { *m = RepoTreeSearchResult{} }
func (m *RepoTreeSearchResult) String() string { return proto.CompactTextString(m) }
func (*RepoTreeSearchResult) ProtoMessage()    {}

type RepoTreeGetOp struct {
	Entry TreeEntrySpec       `protobuf:"bytes,1,opt,name=entry" json:"entry"`
	Opt   *RepoTreeGetOptions `protobuf:"bytes,2,opt,name=opt" json:"opt,omitempty"`
}

func (m *RepoTreeGetOp) Reset()         { *m = RepoTreeGetOp{} }
func (m *RepoTreeGetOp) String() string { return proto.CompactTextString(m) }
func (*RepoTreeGetOp) ProtoMessage()    {}

type RepoTreeSearchOp struct {
	Rev RepoRevSpec            `protobuf:"bytes,1,opt,name=rev" json:"rev"`
	Opt *RepoTreeSearchOptions `protobuf:"bytes,2,opt,name=opt" json:"opt,omitempty"`
}

func (m *RepoTreeSearchOp) Reset()         { *m = RepoTreeSearchOp{} }
func (m *RepoTreeSearchOp) String() string { return proto.CompactTextString(m) }
func (*RepoTreeSearchOp) ProtoMessage()    {}

type VCSSearchResultList struct {
	SearchResults []*vcs.SearchResult `protobuf:"bytes,1,rep,name=search_results" json:"search_results,omitempty"`
}

func (m *VCSSearchResultList) Reset()         { *m = VCSSearchResultList{} }
func (m *VCSSearchResultList) String() string { return proto.CompactTextString(m) }
func (*VCSSearchResultList) ProtoMessage()    {}

type SearchOptions struct {
	Query       string `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty" url:"q" schema:"q"`
	Defs        bool   `protobuf:"varint,2,opt,name=defs,proto3" json:"defs,omitempty"`
	Repos       bool   `protobuf:"varint,3,opt,name=repos,proto3" json:"repos,omitempty"`
	People      bool   `protobuf:"varint,4,opt,name=people,proto3" json:"people,omitempty"`
	Tree        bool   `protobuf:"varint,5,opt,name=tree,proto3" json:"tree,omitempty"`
	ListOptions `protobuf:"bytes,6,opt,name=list_options,embedded=list_options" json:"list_options"`
}

func (m *SearchOptions) Reset()         { *m = SearchOptions{} }
func (m *SearchOptions) String() string { return proto.CompactTextString(m) }
func (*SearchOptions) ProtoMessage()    {}

type SearchResults struct {
	Defs   []*Def                  `protobuf:"bytes,1,rep,name=defs" json:"defs,omitempty"`
	People []*Person               `protobuf:"bytes,2,rep,name=people" json:"people,omitempty"`
	Repos  []*Repo                 `protobuf:"bytes,3,rep,name=repos" json:"repos,omitempty"`
	Tree   []*RepoTreeSearchResult `protobuf:"bytes,4,rep,name=tree" json:"tree,omitempty"`
	// RawQuery is the raw query passed to search.
	RawQuery RawQuery `protobuf:"bytes,5,opt,name=raw_query" json:"raw_query"`
	// Tokens are the unresolved tokens.
	Tokens []PBToken `protobuf:"bytes,6,rep,name=tokens" json:"tokens"`
	// Plan is the query plan used to fetch the results.
	Plan *Plan `protobuf:"bytes,7,opt,name=plan" json:"plan,omitempty"`
	// ResolvedTokens holds the resolved tokens from the original query string.
	ResolvedTokens []PBToken    `protobuf:"bytes,8,rep,name=resolved_tokens" json:"resolved_tokens"`
	ResolveErrors  []TokenError `protobuf:"bytes,9,rep,name=resolve_errors" json:"resolve_errors"`
	// Tips are helpful tips for the user about their query. They are not errors per
	// se, but they use the TokenError type because it allows us to associate a message
	// with a particular token (and JSON de/serialize that).
	Tips []TokenError `protobuf:"bytes,10,rep,name=tips" json:"tips"`
	// Canceled is true if the query was canceled. More information about how to
	// correct the issue can be found in the ResolveErrors and Tips.
	Canceled bool `protobuf:"varint,11,opt,name=canceled,proto3" json:"canceled,omitempty"`
}

func (m *SearchResults) Reset()         { *m = SearchResults{} }
func (m *SearchResults) String() string { return proto.CompactTextString(m) }
func (*SearchResults) ProtoMessage()    {}

type SuggestionList struct {
	Suggestions []*Suggestion `protobuf:"bytes,1,rep,name=suggestions" json:"suggestions,omitempty"`
}

func (m *SuggestionList) Reset()         { *m = SuggestionList{} }
func (m *SuggestionList) String() string { return proto.CompactTextString(m) }
func (*SuggestionList) ProtoMessage()    {}

// SourceCode contains a snippet of code with linked and classed tokens, along with
// other information about the contents.
//
// This data structure is useful when one desires to take full control of rendering
// and manipulating the contents of the requested TreeEntry or snippet, rather than
// dealing with an (annotated) string or parsing text. To obtain this structure in
// the TreeEntry, TokenizedSource must be set to "true" in the RepoTreeGetOptions.
type SourceCode struct {
	// Lines contains all the lines of the contained code snippet.
	Lines       []*SourceCodeLine `protobuf:"bytes,1,rep,name=lines" json:"lines,omitempty"`
	NumRefs     int32             `protobuf:"varint,2,opt,name=num_refs,proto3" json:"num_refs,omitempty"`
	TooManyRefs bool              `protobuf:"varint,3,opt,name=too_many_refs,proto3" json:"too_many_refs,omitempty"`
}

func (m *SourceCode) Reset()         { *m = SourceCode{} }
func (m *SourceCode) String() string { return proto.CompactTextString(m) }
func (*SourceCode) ProtoMessage()    {}

// SourceCodeLine contains all tokens on this line along with other information
// such as byte offsets in original source.
type SourceCodeLine struct {
	// StartByte and EndByte are the start and end offsets in bytes, in the original
	// file.
	StartByte int32 `protobuf:"varint,1,opt,name=start_byte,proto3" json:"start_byte,omitempty"`
	EndByte   int32 `protobuf:"varint,2,opt,name=end_byte,proto3" json:"end_byte,omitempty"`
	// Tokens contains any tokens that may be on this line, including whitespace. New
	// lines ('\n') are not present.
	Tokens []*SourceCodeToken `protobuf:"bytes,3,rep,name=tokens" json:"tokens,omitempty"`
}

func (m *SourceCodeLine) Reset()         { *m = SourceCodeLine{} }
func (m *SourceCodeLine) String() string { return proto.CompactTextString(m) }
func (*SourceCodeLine) ProtoMessage()    {}

// SourceCodeToken contains information about a code token.
type SourceCodeToken struct {
	// Start and end byte offsets in original file.
	StartByte int32 `protobuf:"varint,1,opt,name=start_byte,proto3" json:"-"`
	EndByte   int32 `protobuf:"varint,2,opt,name=end_byte,proto3" json:"-"`
	// If the token is a reference URL contains the DefKey-based URLs for all the
	// definitions at this position.
	URL []string `protobuf:"bytes,3,rep,name=url" json:",omitempty"`
	// IsDef specifies whether the token is a definition.
	IsDef bool `protobuf:"varint,4,opt,name=is_def,proto3" json:",omitempty"`
	// Class specifies the token type as per
	// [google-code-prettify](https://code.google.com/p/google-code-prettify/).
	// All tokens except Whitespace will have this field.
	Class string `protobuf:"bytes,5,opt,name=class,proto3" json:",omitempty"`
	// ExtraClasses may additionally contain other classes for this token, such as
	// for example highlighting in a diff.
	ExtraClasses string `protobuf:"bytes,6,opt,name=extraClasses,proto3" json:",omitempty"`
	// Label is non-whitespace HTML encoded source code.
	Label string `protobuf:"bytes,7,opt,name=label,proto3" json:"label,omitempty"`
}

func (m *SourceCodeToken) Reset()         { *m = SourceCodeToken{} }
func (m *SourceCodeToken) String() string { return proto.CompactTextString(m) }
func (*SourceCodeToken) ProtoMessage()    {}

// TreeEntry is a file or directory in a repository, with additional feedback from
// the formatting operation (if Formatted is true in the options).
type TreeEntry struct {
	*vcsclient.TreeEntry `protobuf:"bytes,1,opt,name=tree_entry,embedded=tree_entry" json:""`
	*vcsclient.FileRange `protobuf:"bytes,2,opt,name=file_range,embedded=file_range" json:"file_range,omitempty"`
	ContentsString       string `protobuf:"bytes,3,opt,name=contents_string,proto3" json:"contents_string,omitempty"`
	// SourceCode is set when TokenizedSource is enabled in RepoTreeGetOptions.
	SourceCode *SourceCode `protobuf:"bytes,4,opt,name=source_code" json:"source_code,omitempty"`
	// FormatResult is only set if this TreeEntry is a file.
	FormatResult *FormatResult `protobuf:"bytes,5,opt,name=format_result" json:"format_result,omitempty"`
}

func (m *TreeEntry) Reset()         { *m = TreeEntry{} }
func (m *TreeEntry) String() string { return proto.CompactTextString(m) }
func (*TreeEntry) ProtoMessage()    {}

type TreeEntrySpec struct {
	RepoRev RepoRevSpec `protobuf:"bytes,1,opt,name=repo_rev" json:"repo_rev"`
	Path    string      `protobuf:"bytes,2,opt,name=path,proto3" json:"path,omitempty"`
}

func (m *TreeEntrySpec) Reset()         { *m = TreeEntrySpec{} }
func (m *TreeEntrySpec) String() string { return proto.CompactTextString(m) }
func (*TreeEntrySpec) ProtoMessage()    {}

// A UnitDelta represents a single source unit that was changed. It has fields for
// the before (Base) and after (Head) versions. If both Base and Head are non-nil,
// then the unit was changed from base to head. Otherwise, one of the fields being
// nil means that the unit did not exist in that revision (e.g., it was added or
// deleted from base to head).
type UnitDelta struct {
	Base *unit.RepoSourceUnit `protobuf:"bytes,1,opt,name=base" json:"base,omitempty"`
	Head *unit.RepoSourceUnit `protobuf:"bytes,2,opt,name=head" json:"head,omitempty"`
}

func (m *UnitDelta) Reset()         { *m = UnitDelta{} }
func (m *UnitDelta) String() string { return proto.CompactTextString(m) }
func (*UnitDelta) ProtoMessage()    {}

// UnitListOptions specifies options for UnitsService.List.
type UnitListOptions struct {
	// RepoRevs constrains the results to a set of repository revisions (given by their
	// URIs plus an optional "@" and a revision specifier). For example,
	// "repo.com/foo@revspec".
	RepoRevs []string `protobuf:"bytes,1,rep,name=repo_revs" json:"repo_revs,omitempty" url:",omitempty,comma"`
	UnitType string   `protobuf:"bytes,2,opt,name=unit_type,proto3" json:"unit_type,omitempty" url:",omitempty"`
	Unit     string   `protobuf:"bytes,3,opt,name=unit,proto3" json:"unit,omitempty" url:",omitempty"`
	// NameQuery specifies a full-text search query over the unit name.
	NameQuery string `protobuf:"bytes,4,opt,name=name_query,proto3" json:"name_query,omitempty" url:",omitempty"`
	// Query specifies a full-text search query over the repo URI, unit name, and unit
	// data.
	Query string `protobuf:"bytes,5,opt,name=query,proto3" json:"query,omitempty" url:",omitempty"`
	// Paging
	ListOptions `protobuf:"bytes,6,opt,name=list_options,embedded=list_options" json:"list_options"`
}

func (m *UnitListOptions) Reset()         { *m = UnitListOptions{} }
func (m *UnitListOptions) String() string { return proto.CompactTextString(m) }
func (*UnitListOptions) ProtoMessage()    {}

// UnitSpec specifies a source unit.
type UnitSpec struct {
	RepoRevSpec `protobuf:"bytes,1,opt,name=repo_rev_spec,embedded=repo_rev_spec" json:"repo_rev_spec"`
	UnitType    string `protobuf:"bytes,2,opt,name=unit_type,proto3" json:"unit_type,omitempty"`
	Unit        string `protobuf:"bytes,3,opt,name=unit,proto3" json:"unit,omitempty"`
}

func (m *UnitSpec) Reset()         { *m = UnitSpec{} }
func (m *UnitSpec) String() string { return proto.CompactTextString(m) }
func (*UnitSpec) ProtoMessage()    {}

type RepoSourceUnitList struct {
	Units []*unit.RepoSourceUnit `protobuf:"bytes,1,rep,name=units" json:"units,omitempty"`
}

func (m *RepoSourceUnitList) Reset()         { *m = RepoSourceUnitList{} }
func (m *RepoSourceUnitList) String() string { return proto.CompactTextString(m) }
func (*RepoSourceUnitList) ProtoMessage()    {}

type DefAuthorList struct {
	DefAuthors []*DefAuthor `protobuf:"bytes,1,rep,name=def_authors" json:"def_authors,omitempty"`
}

func (m *DefAuthorList) Reset()         { *m = DefAuthorList{} }
func (m *DefAuthorList) String() string { return proto.CompactTextString(m) }
func (*DefAuthorList) ProtoMessage()    {}

type DefClientList struct {
	DefClients []*DefClient `protobuf:"bytes,1,rep,name=def_clients" json:"def_clients,omitempty"`
}

func (m *DefClientList) Reset()         { *m = DefClientList{} }
func (m *DefClientList) String() string { return proto.CompactTextString(m) }
func (*DefClientList) ProtoMessage()    {}

type Checklist struct {
	// number of tasks to be done (unchecked)
	Todo int32 `protobuf:"varint,1,opt,name=todo,proto3" json:"todo,omitempty"`
	// number of tasks that are done (checked)
	Done int32 `protobuf:"varint,2,opt,name=done,proto3" json:"done,omitempty"`
}

func (m *Checklist) Reset()         { *m = Checklist{} }
func (m *Checklist) String() string { return proto.CompactTextString(m) }
func (*Checklist) ProtoMessage()    {}

type FileToken struct {
	Path  string               `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	Entry *vcsclient.TreeEntry `protobuf:"bytes,2,opt,name=entry" json:"entry,omitempty"`
}

func (m *FileToken) Reset()         { *m = FileToken{} }
func (m *FileToken) String() string { return proto.CompactTextString(m) }
func (*FileToken) ProtoMessage()    {}

// A Plan is a query plan that fetches the data necessary to satisfy (and provide
// autocomplete suggestions for) a query.
type Plan struct {
	Repos *RepoListOptions       `protobuf:"bytes,1,opt,name=repos" json:"repos,omitempty"`
	Defs  *DefListOptions        `protobuf:"bytes,2,opt,name=defs" json:"defs,omitempty"`
	Users *UsersListOptions      `protobuf:"bytes,3,opt,name=users" json:"users,omitempty"`
	Tree  *RepoTreeSearchOptions `protobuf:"bytes,4,opt,name=tree" json:"tree,omitempty"`
	// TreeRepoRevs constrains the Tree search results to a set of repository revisions
	// (given by their URIs plus an optional "@" and a revision specifier). For
	// example, "repo.com/foo@revspec".
	//
	// TODO(sqs): gorilla/schema does not respect ",comma" and it has no similar
	// option, so specifying multiple repo revs here does NOT work.
	TreeRepoRevs []string `protobuf:"bytes,5,rep,name=tree_repo_revs" json:"tree_repo_revs,omitempty" url:",omitempty,comma"`
}

func (m *Plan) Reset()         { *m = Plan{} }
func (m *Plan) String() string { return proto.CompactTextString(m) }
func (*Plan) ProtoMessage()    {}

// A RawQuery is a raw search query. To obtain the results for the query, it must
// be tokenized, parsed, resolved, planned, etc.
type RawQuery struct {
	// Text is the raw query string from the client.
	Text string `protobuf:"bytes,1,opt,name=text,proto3" json:"text,omitempty"`
	// InsertionPoint is the 0-indexed character offset of the text insertion cursor on
	// the client.
	InsertionPoint int32 `protobuf:"varint,2,opt,name=insertion_point,proto3" json:"insertion_point,omitempty"`
}

func (m *RawQuery) Reset()         { *m = RawQuery{} }
func (m *RawQuery) String() string { return proto.CompactTextString(m) }
func (*RawQuery) ProtoMessage()    {}

// A RepoToken represents a repository, although it does not necessarily uniquely
// identify the repository. It consists of any number of slash-separated path
// components, such as "a/b" or "github.com/foo/bar".
type RepoToken struct {
	URI  string `protobuf:"bytes,1,opt,name=uri,proto3" json:"uri,omitempty"`
	Repo *Repo  `protobuf:"bytes,2,opt,name=repo" json:"repo,omitempty"`
}

func (m *RepoToken) Reset()         { *m = RepoToken{} }
func (m *RepoToken) String() string { return proto.CompactTextString(m) }
func (*RepoToken) ProtoMessage()    {}

// A ResolvedQuery is a query that has been parsed and resolved so that each token
// is given an unambiguous meaning.
type ResolvedQuery struct {
	// Tokens are resolved tokens, each of whose meaning is unambiguous.
	Tokens []PBToken `protobuf:"bytes,1,rep,name=tokens" json:"tokens"`
}

func (m *ResolvedQuery) Reset()         { *m = ResolvedQuery{} }
func (m *ResolvedQuery) String() string { return proto.CompactTextString(m) }
func (*ResolvedQuery) ProtoMessage()    {}

// A RevToken represents a specific revision (either a revspec or a commit ID) of a
// repository (which must be specified by a previous RepoToken in the query).
type RevToken struct {
	// Rev is either a revspec or commit ID
	Rev    string      `protobuf:"bytes,1,opt,name=rev,proto3" json:"rev,omitempty"`
	Commit *vcs.Commit `protobuf:"bytes,2,opt,name=commit" json:"commit,omitempty"`
}

func (m *RevToken) Reset()         { *m = RevToken{} }
func (m *RevToken) String() string { return proto.CompactTextString(m) }
func (*RevToken) ProtoMessage()    {}

// A Suggestion is a possible completion of a query (returned by Suggest method).
// It does not attempt to "complete" a query but rather indicate to the user what
// types of queries are possible.
type Suggestion struct {
	// Query is a suggested query related to the original query.
	Query []PBToken `protobuf:"bytes,1,rep,name=query" json:"query"`
	// QueryString is what the user needs to enter into the search field to search
	// using this suggested query.
	QueryString string `protobuf:"bytes,2,opt,name=query_string,proto3" json:"query_string,omitempty"`
	// Description is the human-readable description of Query (usually generated by
	// calling the Describe func).
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
}

func (m *Suggestion) Reset()         { *m = Suggestion{} }
func (m *Suggestion) String() string { return proto.CompactTextString(m) }
func (*Suggestion) ProtoMessage()    {}

// A UnitToken represents a source unit in a repository.
type UnitToken struct {
	// UnitType is the type of the source unit (e.g., GoPackage).
	UnitType string `protobuf:"bytes,1,opt,name=unit_type,proto3" json:"unit_type,omitempty"`
	// Name is the name of the source unit (e.g., mypkg).
	Name string               `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Unit *unit.RepoSourceUnit `protobuf:"bytes,3,opt,name=unit" json:"unit,omitempty"`
}

func (m *UnitToken) Reset()         { *m = UnitToken{} }
func (m *UnitToken) String() string { return proto.CompactTextString(m) }
func (*UnitToken) ProtoMessage()    {}

// A UserToken represents a user or org, although it does not necessarily uniquely
// identify one. It consists of the string "@" followed by a full or partial
// user/org login.
type UserToken struct {
	Login string `protobuf:"bytes,1,opt,name=login,proto3" json:"login,omitempty"`
	User  *User  `protobuf:"bytes,2,opt,name=user" json:"user,omitempty"`
}

func (m *UserToken) Reset()         { *m = UserToken{} }
func (m *UserToken) String() string { return proto.CompactTextString(m) }
func (*UserToken) ProtoMessage()    {}

// A TokenError is an error about a specific token.
type TokenError struct {
	// Index is the 1-indexed index of the token that caused the error (0 means not
	// associated with any particular token).
	//
	// NOTE: Index is 1-indexed (not 0-indexed) because some TokenErrors don't pertain
	// to a token, and it's misleading if the Index in the JSON is 0 (which could mean
	// that it pertains to the 1st token if index was 0-indexed).
	Index   int32    `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Token   *PBToken `protobuf:"bytes,2,opt,name=token" json:"token,omitempty"`
	Message string   `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
}

func (m *TokenError) Reset()         { *m = TokenError{} }
func (m *TokenError) String() string { return proto.CompactTextString(m) }
func (*TokenError) ProtoMessage()    {}

// A PBToken is a protobuf wrapper (hence the prefix "PB") for a
// search token. Exactly one field must be non-empty.
type PBToken struct {
	Term      string     `protobuf:"bytes,1,opt,name=term,proto3" json:"term,omitempty"`
	AnyToken  string     `protobuf:"bytes,2,opt,name=any_token,proto3" json:"any_token,omitempty"`
	RepoToken *RepoToken `protobuf:"bytes,3,opt,name=repo_token" json:"repo_token,omitempty"`
	RevToken  *RevToken  `protobuf:"bytes,4,opt,name=rev_token" json:"rev_token,omitempty"`
	UnitToken *UnitToken `protobuf:"bytes,5,opt,name=unit_token" json:"unit_token,omitempty"`
	FileToken *FileToken `protobuf:"bytes,6,opt,name=file_token" json:"file_token,omitempty"`
	UserToken *UserToken `protobuf:"bytes,7,opt,name=user_token" json:"user_token,omitempty"`
}

func (m *PBToken) Reset()         { *m = PBToken{} }
func (m *PBToken) String() string { return proto.CompactTextString(m) }
func (*PBToken) ProtoMessage()    {}

// ServerStatus describes the server's status.
type ServerStatus struct {
	// Info contains arbitrary human-readable status information about
	// the server.
	Info string `protobuf:"bytes,1,opt,name=info,proto3" json:"info,omitempty"`
}

func (m *ServerStatus) Reset()         { *m = ServerStatus{} }
func (m *ServerStatus) String() string { return proto.CompactTextString(m) }
func (*ServerStatus) ProtoMessage()    {}

// ServerConfig describes the server's configuration.
//
// DEV NOTE: There is some overlap with Go CLI flag structs. In the
// future we may consolidate these.
type ServerConfig struct {
	// Version is the version of Sourcegraph that this server is
	// running.
	Version string `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	// AppURL is the base URL of the user-facing web application
	// (e.g., "https://sourcegraph.com").
	AppURL string `protobuf:"bytes,2,opt,name=app_url,proto3" json:"app_url,omitempty"`
	// GRPCEndpoint is the external base URL of the GRPC API (e.g.,
	// "https://sourcegraph.com:3100"). This is the address to which
	// external gRPC clients should connect.
	GRPCEndpoint string `protobuf:"bytes,3,opt,name=grpc_endpoint,proto3" json:"grpc_endpoint,omitempty"`
	// HTTPEndpoint is the external base URL of the HTTP API. It
	// typically should end in "/api/" (note the trailing slash). For
	// example, "https://sourcegraph.com/api/". This is the address
	// that external HTTP clients should use.
	HTTPEndpoint string `protobuf:"bytes,4,opt,name=http_endpoint,proto3" json:"http_endpoint,omitempty"`
	// FederationRootURL is the --fed.root-url CLI flag's value. It is
	// the URL of the federation root server, or blank if this server
	// is itself a federation root (in which case IsFederationRoot is
	// true).
	FederationRootURL string `protobuf:"bytes,5,opt,name=federation_root_url,proto3" json:"federation_root_url,omitempty"`
	// IsFederationRoot is whether this server is itself a federation
	// root. If true, then FederationRootURL is empty.
	IsFederationRoot bool `protobuf:"varint,6,opt,name=is_federation_root,proto3" json:"is_federation_root,omitempty"`
	// IDKey is the server's identity key (ID key).
	IDKey string `protobuf:"bytes,7,opt,name=id_key,proto3" json:"id_key,omitempty"`
	// AllowAnonymousReaders is whether anonymous (unauthenticated)
	// users may perform "read" operations, such as viewing
	// repositories.
	AllowAnonymousReaders bool `protobuf:"varint,9,opt,name=allow_anonymous_readers,proto3" json:"allow_anonymous_readers,omitempty"`
}

func (m *ServerConfig) Reset()         { *m = ServerConfig{} }
func (m *ServerConfig) String() string { return proto.CompactTextString(m) }
func (*ServerConfig) ProtoMessage()    {}

// A RegisteredClient is a registered API client.
//
// Many fields correspond to those listed at
// http://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata.
//
// It's called RegisteredClient instead of Client to avoid a name
// conflict with the existing Client (Go) type.
type RegisteredClient struct {
	// ID is a unique identifier for this client.
	ID string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// RedirectURIs is a list of allowed redirect URIs.
	RedirectURIs []string `protobuf:"bytes,2,rep,name=redirect_uris" json:"redirect_uris,omitempty"`
	// ClientName is the name of the client to be presented to the
	// end-user.
	ClientName string `protobuf:"bytes,3,opt,name=client_name,proto3" json:"client_name,omitempty"`
	// LogoURI is a URL to this client's logo.
	LogoURI string `protobuf:"bytes,4,opt,name=logo_uri,proto3" json:"logo_uri,omitempty"`
	// ClientURI is a URL to this client's homepage.
	ClientURI string `protobuf:"bytes,5,opt,name=client_uri,proto3" json:"client_uri,omitempty"`
	// JWKS is the client's JSON Web Key Set. It contains the client's
	// public keys, if any.
	JWKS string `protobuf:"bytes,6,opt,name=jwks,proto3" json:"jwks,omitempty"`
	// ClientSecret is the secret value that authenticates the
	// client. It may be empty (e.g., if JWKS keys are used for
	// authentication instead).
	ClientSecret string `protobuf:"bytes,7,opt,name=client_secret,proto3" json:"client_secret,omitempty"`
	// Description is a human-readable description of this API client
	// that's shown to the user during, e.g., OAuth2 authentication.
	Description string `protobuf:"bytes,8,opt,name=description,proto3" json:"description,omitempty"`
	// Meta holds arbitrary metadata about this API client. The
	// structure is defined by the API client and is opaque to the
	// server.
	Meta map[string]string `protobuf:"bytes,9,rep,name=meta" json:"meta,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// RegisteredClientType describes this client's type.
	Type RegisteredClientType `protobuf:"varint,10,opt,name=type,proto3,enum=sourcegraph.RegisteredClientType" json:"type,omitempty"`
	// CreatedAt is when this API client's record was created.
	CreatedAt pbtypes.Timestamp `protobuf:"bytes,11,opt,name=created_at" json:"created_at"`
	// UpdatedAt is when this API client's record was last updated.
	UpdatedAt pbtypes.Timestamp `protobuf:"bytes,12,opt,name=updated_at" json:"updated_at"`
}

func (m *RegisteredClient) Reset()         { *m = RegisteredClient{} }
func (m *RegisteredClient) String() string { return proto.CompactTextString(m) }
func (*RegisteredClient) ProtoMessage()    {}

// A RegisteredClientSpec uniquely identifies a RegisteredClient.
type RegisteredClientSpec struct {
	// ID is the client's ID.
	ID string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *RegisteredClientSpec) Reset()         { *m = RegisteredClientSpec{} }
func (m *RegisteredClientSpec) String() string { return proto.CompactTextString(m) }
func (*RegisteredClientSpec) ProtoMessage()    {}

// A RegisteredClientCredentials authenticates a RegisteredClient.
type RegisteredClientCredentials struct {
	// ID is the client's ID.
	ID string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Secret is the client's secret.
	Secret string `protobuf:"bytes,2,opt,name=secret,proto3" json:"secret,omitempty"`
}

func (m *RegisteredClientCredentials) Reset()         { *m = RegisteredClientCredentials{} }
func (m *RegisteredClientCredentials) String() string { return proto.CompactTextString(m) }
func (*RegisteredClientCredentials) ProtoMessage()    {}

// RegisteredClientListOptions configures a call to
// RegisteredClients.List.
type RegisteredClientListOptions struct {
	Type        RegisteredClientType `protobuf:"varint,1,opt,name=type,proto3,enum=sourcegraph.RegisteredClientType" json:"type,omitempty"`
	ListOptions `protobuf:"bytes,2,opt,name=list_options,embedded=list_options" json:"list_options"`
}

func (m *RegisteredClientListOptions) Reset()         { *m = RegisteredClientListOptions{} }
func (m *RegisteredClientListOptions) String() string { return proto.CompactTextString(m) }
func (*RegisteredClientListOptions) ProtoMessage()    {}

// RegisteredClientList holds a list of clients.
type RegisteredClientList struct {
	Clients      []*RegisteredClient `protobuf:"bytes,1,rep,name=clients" json:"clients,omitempty"`
	ListResponse `protobuf:"bytes,2,opt,name=list_response,embedded=list_response" json:"list_response"`
}

func (m *RegisteredClientList) Reset()         { *m = RegisteredClientList{} }
func (m *RegisteredClientList) String() string { return proto.CompactTextString(m) }
func (*RegisteredClientList) ProtoMessage()    {}

// MetricsSnapshots encodes
type MetricsSnapshot struct {
	// Type is the encoding of TelemetryData
	Type TelemetryType `protobuf:"varint,1,opt,name=type,proto3,enum=sourcegraph.TelemetryType" json:"type,omitempty"`
	// TelemetryData is the encoded metrics
	TelemetryData []byte `protobuf:"bytes,2,opt,name=telemetry_data,proto3" json:"telemetry_data,omitempty"`
}

func (m *MetricsSnapshot) Reset()         { *m = MetricsSnapshot{} }
func (m *MetricsSnapshot) String() string { return proto.CompactTextString(m) }
func (*MetricsSnapshot) ProtoMessage()    {}

func init() {
	proto.RegisterEnum("sourcegraph.RegisteredClientType", RegisteredClientType_name, RegisteredClientType_value)
	proto.RegisterEnum("sourcegraph.TelemetryType", TelemetryType_name, TelemetryType_value)
}

// Client API for RepoBadges service

type RepoBadgesClient interface {
	// ListBadges lists the available badges for repo.
	ListBadges(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*BadgeList, error)
	// ListCounters lists the available counters for repo.
	ListCounters(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*CounterList, error)
	// RecordHit records a visit to a repo (that will be reflected in
	// its counter).
	RecordHit(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// CountHits returns the hit count (optionally in a recent time
	// period).
	CountHits(ctx context.Context, in *RepoBadgesCountHitsOp, opts ...grpc.CallOption) (*RepoBadgesCountHitsResult, error)
}

type repoBadgesClient struct {
	cc *grpc.ClientConn
}

func NewRepoBadgesClient(cc *grpc.ClientConn) RepoBadgesClient {
	return &repoBadgesClient{cc}
}

func (c *repoBadgesClient) ListBadges(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*BadgeList, error) {
	out := new(BadgeList)
	err := grpc.Invoke(ctx, "/sourcegraph.RepoBadges/ListBadges", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repoBadgesClient) ListCounters(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*CounterList, error) {
	out := new(CounterList)
	err := grpc.Invoke(ctx, "/sourcegraph.RepoBadges/ListCounters", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repoBadgesClient) RecordHit(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.RepoBadges/RecordHit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repoBadgesClient) CountHits(ctx context.Context, in *RepoBadgesCountHitsOp, opts ...grpc.CallOption) (*RepoBadgesCountHitsResult, error) {
	out := new(RepoBadgesCountHitsResult)
	err := grpc.Invoke(ctx, "/sourcegraph.RepoBadges/CountHits", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for RepoBadges service

type RepoBadgesServer interface {
	// ListBadges lists the available badges for repo.
	ListBadges(context.Context, *RepoSpec) (*BadgeList, error)
	// ListCounters lists the available counters for repo.
	ListCounters(context.Context, *RepoSpec) (*CounterList, error)
	// RecordHit records a visit to a repo (that will be reflected in
	// its counter).
	RecordHit(context.Context, *RepoSpec) (*pbtypes1.Void, error)
	// CountHits returns the hit count (optionally in a recent time
	// period).
	CountHits(context.Context, *RepoBadgesCountHitsOp) (*RepoBadgesCountHitsResult, error)
}

func RegisterRepoBadgesServer(s *grpc.Server, srv RepoBadgesServer) {
	s.RegisterService(&_RepoBadges_serviceDesc, srv)
}

func _RepoBadges_ListBadges_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(RepoSpec)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(RepoBadgesServer).ListBadges(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RepoBadges_ListCounters_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(RepoSpec)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(RepoBadgesServer).ListCounters(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RepoBadges_RecordHit_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(RepoSpec)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(RepoBadgesServer).RecordHit(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RepoBadges_CountHits_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(RepoBadgesCountHitsOp)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(RepoBadgesServer).CountHits(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _RepoBadges_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.RepoBadges",
	HandlerType: (*RepoBadgesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListBadges",
			Handler:    _RepoBadges_ListBadges_Handler,
		},
		{
			MethodName: "ListCounters",
			Handler:    _RepoBadges_ListCounters_Handler,
		},
		{
			MethodName: "RecordHit",
			Handler:    _RepoBadges_RecordHit_Handler,
		},
		{
			MethodName: "CountHits",
			Handler:    _RepoBadges_CountHits_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for RepoStatuses service

type RepoStatusesClient interface {
	// GetCombined fetches the combined repository status for the given commit.
	GetCombined(ctx context.Context, in *RepoRevSpec, opts ...grpc.CallOption) (*CombinedStatus, error)
	// Create creates a repository status for the given commit.
	Create(ctx context.Context, in *RepoStatusesCreateOp, opts ...grpc.CallOption) (*RepoStatus, error)
}

type repoStatusesClient struct {
	cc *grpc.ClientConn
}

func NewRepoStatusesClient(cc *grpc.ClientConn) RepoStatusesClient {
	return &repoStatusesClient{cc}
}

func (c *repoStatusesClient) GetCombined(ctx context.Context, in *RepoRevSpec, opts ...grpc.CallOption) (*CombinedStatus, error) {
	out := new(CombinedStatus)
	err := grpc.Invoke(ctx, "/sourcegraph.RepoStatuses/GetCombined", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repoStatusesClient) Create(ctx context.Context, in *RepoStatusesCreateOp, opts ...grpc.CallOption) (*RepoStatus, error) {
	out := new(RepoStatus)
	err := grpc.Invoke(ctx, "/sourcegraph.RepoStatuses/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for RepoStatuses service

type RepoStatusesServer interface {
	// GetCombined fetches the combined repository status for the given commit.
	GetCombined(context.Context, *RepoRevSpec) (*CombinedStatus, error)
	// Create creates a repository status for the given commit.
	Create(context.Context, *RepoStatusesCreateOp) (*RepoStatus, error)
}

func RegisterRepoStatusesServer(s *grpc.Server, srv RepoStatusesServer) {
	s.RegisterService(&_RepoStatuses_serviceDesc, srv)
}

func _RepoStatuses_GetCombined_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(RepoRevSpec)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(RepoStatusesServer).GetCombined(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RepoStatuses_Create_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(RepoStatusesCreateOp)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(RepoStatusesServer).Create(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _RepoStatuses_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.RepoStatuses",
	HandlerType: (*RepoStatusesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetCombined",
			Handler:    _RepoStatuses_GetCombined_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _RepoStatuses_Create_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Repos service

type ReposClient interface {
	// Get fetches a repository.
	Get(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*Repo, error)
	// List repositories.
	List(ctx context.Context, in *RepoListOptions, opts ...grpc.CallOption) (*RepoList, error)
	// Create creates a new repository.
	Create(ctx context.Context, in *ReposCreateOp, opts ...grpc.CallOption) (*Repo, error)
	// Delete removes a repository.
	Delete(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// GetReadme fetches the formatted README file for a repository.
	GetReadme(ctx context.Context, in *RepoRevSpec, opts ...grpc.CallOption) (*Readme, error)
	// Enable enables the specified repository.
	Enable(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// Disable disables the specified repository.
	Disable(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// GetConfig retrieves the configuration for a repository. To
	// update the config, use Enable or Disable (direct updating is
	// not currently supported).
	GetConfig(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*RepoConfig, error)
	// TODO(sqs!nodb-ctx): move these to a "VCS" service (not Repos)
	// TODO(slimsag): add google.api.http annotations to these once moved
	GetCommit(ctx context.Context, in *RepoRevSpec, opts ...grpc.CallOption) (*vcs.Commit, error)
	// ListCommits returns the list of commits that span between the revisions
	// specified in the given DeltaSpec. By default, it will return 1 page of
	// commits with a maximum of DefaultPerPage entries. To retrieve all commits
	// the PerPage value can be set to -1.
	ListCommits(ctx context.Context, in *ReposListCommitsOp, opts ...grpc.CallOption) (*CommitList, error)
	ListBranches(ctx context.Context, in *ReposListBranchesOp, opts ...grpc.CallOption) (*BranchList, error)
	ListTags(ctx context.Context, in *ReposListTagsOp, opts ...grpc.CallOption) (*TagList, error)
	// ListCommitters returns the list of authors who have contributed
	// to the main branch of the repo.
	ListCommitters(ctx context.Context, in *ReposListCommittersOp, opts ...grpc.CallOption) (*CommitterList, error)
}

type reposClient struct {
	cc *grpc.ClientConn
}

func NewReposClient(cc *grpc.ClientConn) ReposClient {
	return &reposClient{cc}
}

func (c *reposClient) Get(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*Repo, error) {
	out := new(Repo)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) List(ctx context.Context, in *RepoListOptions, opts ...grpc.CallOption) (*RepoList, error) {
	out := new(RepoList)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) Create(ctx context.Context, in *ReposCreateOp, opts ...grpc.CallOption) (*Repo, error) {
	out := new(Repo)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) Delete(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) GetReadme(ctx context.Context, in *RepoRevSpec, opts ...grpc.CallOption) (*Readme, error) {
	out := new(Readme)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/GetReadme", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) Enable(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/Enable", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) Disable(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/Disable", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) GetConfig(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*RepoConfig, error) {
	out := new(RepoConfig)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/GetConfig", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) GetCommit(ctx context.Context, in *RepoRevSpec, opts ...grpc.CallOption) (*vcs.Commit, error) {
	out := new(vcs.Commit)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/GetCommit", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) ListCommits(ctx context.Context, in *ReposListCommitsOp, opts ...grpc.CallOption) (*CommitList, error) {
	out := new(CommitList)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/ListCommits", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) ListBranches(ctx context.Context, in *ReposListBranchesOp, opts ...grpc.CallOption) (*BranchList, error) {
	out := new(BranchList)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/ListBranches", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) ListTags(ctx context.Context, in *ReposListTagsOp, opts ...grpc.CallOption) (*TagList, error) {
	out := new(TagList)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/ListTags", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reposClient) ListCommitters(ctx context.Context, in *ReposListCommittersOp, opts ...grpc.CallOption) (*CommitterList, error) {
	out := new(CommitterList)
	err := grpc.Invoke(ctx, "/sourcegraph.Repos/ListCommitters", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Repos service

type ReposServer interface {
	// Get fetches a repository.
	Get(context.Context, *RepoSpec) (*Repo, error)
	// List repositories.
	List(context.Context, *RepoListOptions) (*RepoList, error)
	// Create creates a new repository.
	Create(context.Context, *ReposCreateOp) (*Repo, error)
	// Delete removes a repository.
	Delete(context.Context, *RepoSpec) (*pbtypes1.Void, error)
	// GetReadme fetches the formatted README file for a repository.
	GetReadme(context.Context, *RepoRevSpec) (*Readme, error)
	// Enable enables the specified repository.
	Enable(context.Context, *RepoSpec) (*pbtypes1.Void, error)
	// Disable disables the specified repository.
	Disable(context.Context, *RepoSpec) (*pbtypes1.Void, error)
	// GetConfig retrieves the configuration for a repository. To
	// update the config, use Enable or Disable (direct updating is
	// not currently supported).
	GetConfig(context.Context, *RepoSpec) (*RepoConfig, error)
	// TODO(sqs!nodb-ctx): move these to a "VCS" service (not Repos)
	// TODO(slimsag): add google.api.http annotations to these once moved
	GetCommit(context.Context, *RepoRevSpec) (*vcs.Commit, error)
	// ListCommits returns the list of commits that span between the revisions
	// specified in the given DeltaSpec. By default, it will return 1 page of
	// commits with a maximum of DefaultPerPage entries. To retrieve all commits
	// the PerPage value can be set to -1.
	ListCommits(context.Context, *ReposListCommitsOp) (*CommitList, error)
	ListBranches(context.Context, *ReposListBranchesOp) (*BranchList, error)
	ListTags(context.Context, *ReposListTagsOp) (*TagList, error)
	// ListCommitters returns the list of authors who have contributed
	// to the main branch of the repo.
	ListCommitters(context.Context, *ReposListCommittersOp) (*CommitterList, error)
}

func RegisterReposServer(s *grpc.Server, srv ReposServer) {
	s.RegisterService(&_Repos_serviceDesc, srv)
}

func _Repos_Get_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(RepoSpec)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_List_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(RepoListOptions)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).List(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_Create_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(ReposCreateOp)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).Create(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_Delete_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(RepoSpec)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).Delete(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_GetReadme_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(RepoRevSpec)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).GetReadme(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_Enable_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(RepoSpec)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).Enable(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_Disable_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(RepoSpec)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).Disable(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_GetConfig_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(RepoSpec)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).GetConfig(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_GetCommit_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(RepoRevSpec)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).GetCommit(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_ListCommits_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(ReposListCommitsOp)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).ListCommits(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_ListBranches_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(ReposListBranchesOp)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).ListBranches(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_ListTags_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(ReposListTagsOp)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).ListTags(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Repos_ListCommitters_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(ReposListCommittersOp)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ReposServer).ListCommitters(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Repos_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Repos",
	HandlerType: (*ReposServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Repos_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Repos_List_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _Repos_Create_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Repos_Delete_Handler,
		},
		{
			MethodName: "GetReadme",
			Handler:    _Repos_GetReadme_Handler,
		},
		{
			MethodName: "Enable",
			Handler:    _Repos_Enable_Handler,
		},
		{
			MethodName: "Disable",
			Handler:    _Repos_Disable_Handler,
		},
		{
			MethodName: "GetConfig",
			Handler:    _Repos_GetConfig_Handler,
		},
		{
			MethodName: "GetCommit",
			Handler:    _Repos_GetCommit_Handler,
		},
		{
			MethodName: "ListCommits",
			Handler:    _Repos_ListCommits_Handler,
		},
		{
			MethodName: "ListBranches",
			Handler:    _Repos_ListBranches_Handler,
		},
		{
			MethodName: "ListTags",
			Handler:    _Repos_ListTags_Handler,
		},
		{
			MethodName: "ListCommitters",
			Handler:    _Repos_ListCommitters_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Changesets service

type ChangesetsClient interface {
	// Create creates a new Changeset and returns it, populating
	// its fields, such as ID and CreatedAt.
	Create(ctx context.Context, in *ChangesetCreateOp, opts ...grpc.CallOption) (*Changeset, error)
	// Get returns the changeset by RepoSpec and ID.
	Get(ctx context.Context, in *ChangesetSpec, opts ...grpc.CallOption) (*Changeset, error)
	// List lists changesets for a repository.
	List(ctx context.Context, in *ChangesetListOp, opts ...grpc.CallOption) (*ChangesetList, error)
	// UpdateChangeset updates a changeset's fields and returns the
	// update event. If no update occurred, it returns nil.
	Update(ctx context.Context, in *ChangesetUpdateOp, opts ...grpc.CallOption) (*ChangesetEvent, error)
	// CreateReview creates a new Review and returns it, populating
	// its fields, such as ID and CreatedAt.
	CreateReview(ctx context.Context, in *ChangesetCreateReviewOp, opts ...grpc.CallOption) (*ChangesetReview, error)
	// ListReviews returns all reviews for a given changeset.
	ListReviews(ctx context.Context, in *ChangesetListReviewsOp, opts ...grpc.CallOption) (*ChangesetReviewList, error)
	// ListEvents returns all the events that occurred on a given changeset.
	ListEvents(ctx context.Context, in *ChangesetSpec, opts ...grpc.CallOption) (*ChangesetEventList, error)
}

type changesetsClient struct {
	cc *grpc.ClientConn
}

func NewChangesetsClient(cc *grpc.ClientConn) ChangesetsClient {
	return &changesetsClient{cc}
}

func (c *changesetsClient) Create(ctx context.Context, in *ChangesetCreateOp, opts ...grpc.CallOption) (*Changeset, error) {
	out := new(Changeset)
	err := grpc.Invoke(ctx, "/sourcegraph.Changesets/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *changesetsClient) Get(ctx context.Context, in *ChangesetSpec, opts ...grpc.CallOption) (*Changeset, error) {
	out := new(Changeset)
	err := grpc.Invoke(ctx, "/sourcegraph.Changesets/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *changesetsClient) List(ctx context.Context, in *ChangesetListOp, opts ...grpc.CallOption) (*ChangesetList, error) {
	out := new(ChangesetList)
	err := grpc.Invoke(ctx, "/sourcegraph.Changesets/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *changesetsClient) Update(ctx context.Context, in *ChangesetUpdateOp, opts ...grpc.CallOption) (*ChangesetEvent, error) {
	out := new(ChangesetEvent)
	err := grpc.Invoke(ctx, "/sourcegraph.Changesets/Update", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *changesetsClient) CreateReview(ctx context.Context, in *ChangesetCreateReviewOp, opts ...grpc.CallOption) (*ChangesetReview, error) {
	out := new(ChangesetReview)
	err := grpc.Invoke(ctx, "/sourcegraph.Changesets/CreateReview", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *changesetsClient) ListReviews(ctx context.Context, in *ChangesetListReviewsOp, opts ...grpc.CallOption) (*ChangesetReviewList, error) {
	out := new(ChangesetReviewList)
	err := grpc.Invoke(ctx, "/sourcegraph.Changesets/ListReviews", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *changesetsClient) ListEvents(ctx context.Context, in *ChangesetSpec, opts ...grpc.CallOption) (*ChangesetEventList, error) {
	out := new(ChangesetEventList)
	err := grpc.Invoke(ctx, "/sourcegraph.Changesets/ListEvents", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Changesets service

type ChangesetsServer interface {
	// Create creates a new Changeset and returns it, populating
	// its fields, such as ID and CreatedAt.
	Create(context.Context, *ChangesetCreateOp) (*Changeset, error)
	// Get returns the changeset by RepoSpec and ID.
	Get(context.Context, *ChangesetSpec) (*Changeset, error)
	// List lists changesets for a repository.
	List(context.Context, *ChangesetListOp) (*ChangesetList, error)
	// UpdateChangeset updates a changeset's fields and returns the
	// update event. If no update occurred, it returns nil.
	Update(context.Context, *ChangesetUpdateOp) (*ChangesetEvent, error)
	// CreateReview creates a new Review and returns it, populating
	// its fields, such as ID and CreatedAt.
	CreateReview(context.Context, *ChangesetCreateReviewOp) (*ChangesetReview, error)
	// ListReviews returns all reviews for a given changeset.
	ListReviews(context.Context, *ChangesetListReviewsOp) (*ChangesetReviewList, error)
	// ListEvents returns all the events that occurred on a given changeset.
	ListEvents(context.Context, *ChangesetSpec) (*ChangesetEventList, error)
}

func RegisterChangesetsServer(s *grpc.Server, srv ChangesetsServer) {
	s.RegisterService(&_Changesets_serviceDesc, srv)
}

func _Changesets_Create_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(ChangesetCreateOp)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ChangesetsServer).Create(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Changesets_Get_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(ChangesetSpec)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ChangesetsServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Changesets_List_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(ChangesetListOp)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ChangesetsServer).List(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Changesets_Update_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(ChangesetUpdateOp)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ChangesetsServer).Update(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Changesets_CreateReview_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(ChangesetCreateReviewOp)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ChangesetsServer).CreateReview(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Changesets_ListReviews_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(ChangesetListReviewsOp)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ChangesetsServer).ListReviews(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Changesets_ListEvents_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(ChangesetSpec)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(ChangesetsServer).ListEvents(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Changesets_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Changesets",
	HandlerType: (*ChangesetsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _Changesets_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _Changesets_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Changesets_List_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _Changesets_Update_Handler,
		},
		{
			MethodName: "CreateReview",
			Handler:    _Changesets_CreateReview_Handler,
		},
		{
			MethodName: "ListReviews",
			Handler:    _Changesets_ListReviews_Handler,
		},
		{
			MethodName: "ListEvents",
			Handler:    _Changesets_ListEvents_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Discussions service

type DiscussionsClient interface {
	// Create creates a new Discussion and returns it, populating its
	// fields, such as ID and CreatedAt.
	Create(ctx context.Context, in *Discussion, opts ...grpc.CallOption) (*Discussion, error)
	// Get returns the Discussion by RepoSpec and ID.
	Get(ctx context.Context, in *DiscussionSpec, opts ...grpc.CallOption) (*Discussion, error)
	// List lists changesets for a DefKey
	List(ctx context.Context, in *DiscussionListOp, opts ...grpc.CallOption) (*DiscussionList, error)
	// CreateComment creates a new DiscussionComment and returns it,
	// populating its fields, such as ID and CreatedAt.
	CreateComment(ctx context.Context, in *DiscussionCommentCreateOp, opts ...grpc.CallOption) (*DiscussionComment, error)
	// UpdateRating either adds or removes a star by a User
	UpdateRating(ctx context.Context, in *DiscussionRatingUpdateOp, opts ...grpc.CallOption) (*pbtypes1.Void, error)
}

type discussionsClient struct {
	cc *grpc.ClientConn
}

func NewDiscussionsClient(cc *grpc.ClientConn) DiscussionsClient {
	return &discussionsClient{cc}
}

func (c *discussionsClient) Create(ctx context.Context, in *Discussion, opts ...grpc.CallOption) (*Discussion, error) {
	out := new(Discussion)
	err := grpc.Invoke(ctx, "/sourcegraph.Discussions/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *discussionsClient) Get(ctx context.Context, in *DiscussionSpec, opts ...grpc.CallOption) (*Discussion, error) {
	out := new(Discussion)
	err := grpc.Invoke(ctx, "/sourcegraph.Discussions/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *discussionsClient) List(ctx context.Context, in *DiscussionListOp, opts ...grpc.CallOption) (*DiscussionList, error) {
	out := new(DiscussionList)
	err := grpc.Invoke(ctx, "/sourcegraph.Discussions/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *discussionsClient) CreateComment(ctx context.Context, in *DiscussionCommentCreateOp, opts ...grpc.CallOption) (*DiscussionComment, error) {
	out := new(DiscussionComment)
	err := grpc.Invoke(ctx, "/sourcegraph.Discussions/CreateComment", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *discussionsClient) UpdateRating(ctx context.Context, in *DiscussionRatingUpdateOp, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.Discussions/UpdateRating", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Discussions service

type DiscussionsServer interface {
	// Create creates a new Discussion and returns it, populating its
	// fields, such as ID and CreatedAt.
	Create(context.Context, *Discussion) (*Discussion, error)
	// Get returns the Discussion by RepoSpec and ID.
	Get(context.Context, *DiscussionSpec) (*Discussion, error)
	// List lists changesets for a DefKey
	List(context.Context, *DiscussionListOp) (*DiscussionList, error)
	// CreateComment creates a new DiscussionComment and returns it,
	// populating its fields, such as ID and CreatedAt.
	CreateComment(context.Context, *DiscussionCommentCreateOp) (*DiscussionComment, error)
	// UpdateRating either adds or removes a star by a User
	UpdateRating(context.Context, *DiscussionRatingUpdateOp) (*pbtypes1.Void, error)
}

func RegisterDiscussionsServer(s *grpc.Server, srv DiscussionsServer) {
	s.RegisterService(&_Discussions_serviceDesc, srv)
}

func _Discussions_Create_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(Discussion)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(DiscussionsServer).Create(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Discussions_Get_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(DiscussionSpec)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(DiscussionsServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Discussions_List_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(DiscussionListOp)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(DiscussionsServer).List(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Discussions_CreateComment_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(DiscussionCommentCreateOp)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(DiscussionsServer).CreateComment(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Discussions_UpdateRating_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(DiscussionRatingUpdateOp)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(DiscussionsServer).UpdateRating(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Discussions_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Discussions",
	HandlerType: (*DiscussionsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _Discussions_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _Discussions_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Discussions_List_Handler,
		},
		{
			MethodName: "CreateComment",
			Handler:    _Discussions_CreateComment_Handler,
		},
		{
			MethodName: "UpdateRating",
			Handler:    _Discussions_UpdateRating_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for MirrorRepos service

type MirrorReposClient interface {
	// Refresh fetches the newest VCS data from the repo's origin.
	RefreshVCS(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error)
}

type mirrorReposClient struct {
	cc *grpc.ClientConn
}

func NewMirrorReposClient(cc *grpc.ClientConn) MirrorReposClient {
	return &mirrorReposClient{cc}
}

func (c *mirrorReposClient) RefreshVCS(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.MirrorRepos/RefreshVCS", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for MirrorRepos service

type MirrorReposServer interface {
	// Refresh fetches the newest VCS data from the repo's origin.
	RefreshVCS(context.Context, *RepoSpec) (*pbtypes1.Void, error)
}

func RegisterMirrorReposServer(s *grpc.Server, srv MirrorReposServer) {
	s.RegisterService(&_MirrorRepos_serviceDesc, srv)
}

func _MirrorRepos_RefreshVCS_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(RepoSpec)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(MirrorReposServer).RefreshVCS(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _MirrorRepos_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.MirrorRepos",
	HandlerType: (*MirrorReposServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RefreshVCS",
			Handler:    _MirrorRepos_RefreshVCS_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for MirroredRepoSSHKeys service

type MirroredRepoSSHKeysClient interface {
	Create(ctx context.Context, in *MirroredRepoSSHKeysCreateOp, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	Get(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*SSHPrivateKey, error)
	Delete(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error)
}

type mirroredRepoSSHKeysClient struct {
	cc *grpc.ClientConn
}

func NewMirroredRepoSSHKeysClient(cc *grpc.ClientConn) MirroredRepoSSHKeysClient {
	return &mirroredRepoSSHKeysClient{cc}
}

func (c *mirroredRepoSSHKeysClient) Create(ctx context.Context, in *MirroredRepoSSHKeysCreateOp, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.MirroredRepoSSHKeys/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mirroredRepoSSHKeysClient) Get(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*SSHPrivateKey, error) {
	out := new(SSHPrivateKey)
	err := grpc.Invoke(ctx, "/sourcegraph.MirroredRepoSSHKeys/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mirroredRepoSSHKeysClient) Delete(ctx context.Context, in *RepoSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.MirroredRepoSSHKeys/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for MirroredRepoSSHKeys service

type MirroredRepoSSHKeysServer interface {
	Create(context.Context, *MirroredRepoSSHKeysCreateOp) (*pbtypes1.Void, error)
	Get(context.Context, *RepoSpec) (*SSHPrivateKey, error)
	Delete(context.Context, *RepoSpec) (*pbtypes1.Void, error)
}

func RegisterMirroredRepoSSHKeysServer(s *grpc.Server, srv MirroredRepoSSHKeysServer) {
	s.RegisterService(&_MirroredRepoSSHKeys_serviceDesc, srv)
}

func _MirroredRepoSSHKeys_Create_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(MirroredRepoSSHKeysCreateOp)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(MirroredRepoSSHKeysServer).Create(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _MirroredRepoSSHKeys_Get_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(RepoSpec)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(MirroredRepoSSHKeysServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _MirroredRepoSSHKeys_Delete_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(RepoSpec)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(MirroredRepoSSHKeysServer).Delete(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _MirroredRepoSSHKeys_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.MirroredRepoSSHKeys",
	HandlerType: (*MirroredRepoSSHKeysServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _MirroredRepoSSHKeys_Create_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _MirroredRepoSSHKeys_Get_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _MirroredRepoSSHKeys_Delete_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Builds service

type BuildsClient interface {
	// Get fetches a build.
	Get(ctx context.Context, in *BuildSpec, opts ...grpc.CallOption) (*Build, error)
	// GetRepoBuildInfo gets the best-match build for a specific repo revspec. It
	// returns additional information about the build, such as whether it is exactly
	// up-to-date with the revspec or a few commits behind the revspec. The opt param
	// controls what is returned in this case.
	GetRepoBuildInfo(ctx context.Context, in *BuildsGetRepoBuildInfoOp, opts ...grpc.CallOption) (*RepoBuildInfo, error)
	// List builds.
	List(ctx context.Context, in *BuildListOptions, opts ...grpc.CallOption) (*BuildList, error)
	// Create a new build. The build will run asynchronously (Create does not wait for
	// it to return. To monitor the build's status, use Get.)
	Create(ctx context.Context, in *BuildsCreateOp, opts ...grpc.CallOption) (*Build, error)
	// Update updates information about a build and returns the build after the update
	// has been applied.
	Update(ctx context.Context, in *BuildsUpdateOp, opts ...grpc.CallOption) (*Build, error)
	// ListBuildTasks lists the tasks associated with a build.
	ListBuildTasks(ctx context.Context, in *BuildsListBuildTasksOp, opts ...grpc.CallOption) (*BuildTaskList, error)
	// CreateTasks creates tasks associated with a build and returns them with their
	// TID fields set.
	CreateTasks(ctx context.Context, in *BuildsCreateTasksOp, opts ...grpc.CallOption) (*BuildTaskList, error)
	// UpdateTask updates a task associated with a build.
	UpdateTask(ctx context.Context, in *BuildsUpdateTaskOp, opts ...grpc.CallOption) (*BuildTask, error)
	// GetLog gets log entries associated with a build.
	GetLog(ctx context.Context, in *BuildsGetLogOp, opts ...grpc.CallOption) (*LogEntries, error)
	// GetTaskLog gets log entries associated with a task.
	GetTaskLog(ctx context.Context, in *BuildsGetTaskLogOp, opts ...grpc.CallOption) (*LogEntries, error)
	// DequeueNext returns the next queued build and marks it as
	// having started (atomically). If there are no builds in the
	// queue, a NotFound error is returned.
	DequeueNext(ctx context.Context, in *BuildsDequeueNextOp, opts ...grpc.CallOption) (*Build, error)
}

type buildsClient struct {
	cc *grpc.ClientConn
}

func NewBuildsClient(cc *grpc.ClientConn) BuildsClient {
	return &buildsClient{cc}
}

func (c *buildsClient) Get(ctx context.Context, in *BuildSpec, opts ...grpc.CallOption) (*Build, error) {
	out := new(Build)
	err := grpc.Invoke(ctx, "/sourcegraph.Builds/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) GetRepoBuildInfo(ctx context.Context, in *BuildsGetRepoBuildInfoOp, opts ...grpc.CallOption) (*RepoBuildInfo, error) {
	out := new(RepoBuildInfo)
	err := grpc.Invoke(ctx, "/sourcegraph.Builds/GetRepoBuildInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) List(ctx context.Context, in *BuildListOptions, opts ...grpc.CallOption) (*BuildList, error) {
	out := new(BuildList)
	err := grpc.Invoke(ctx, "/sourcegraph.Builds/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) Create(ctx context.Context, in *BuildsCreateOp, opts ...grpc.CallOption) (*Build, error) {
	out := new(Build)
	err := grpc.Invoke(ctx, "/sourcegraph.Builds/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) Update(ctx context.Context, in *BuildsUpdateOp, opts ...grpc.CallOption) (*Build, error) {
	out := new(Build)
	err := grpc.Invoke(ctx, "/sourcegraph.Builds/Update", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) ListBuildTasks(ctx context.Context, in *BuildsListBuildTasksOp, opts ...grpc.CallOption) (*BuildTaskList, error) {
	out := new(BuildTaskList)
	err := grpc.Invoke(ctx, "/sourcegraph.Builds/ListBuildTasks", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) CreateTasks(ctx context.Context, in *BuildsCreateTasksOp, opts ...grpc.CallOption) (*BuildTaskList, error) {
	out := new(BuildTaskList)
	err := grpc.Invoke(ctx, "/sourcegraph.Builds/CreateTasks", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) UpdateTask(ctx context.Context, in *BuildsUpdateTaskOp, opts ...grpc.CallOption) (*BuildTask, error) {
	out := new(BuildTask)
	err := grpc.Invoke(ctx, "/sourcegraph.Builds/UpdateTask", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) GetLog(ctx context.Context, in *BuildsGetLogOp, opts ...grpc.CallOption) (*LogEntries, error) {
	out := new(LogEntries)
	err := grpc.Invoke(ctx, "/sourcegraph.Builds/GetLog", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) GetTaskLog(ctx context.Context, in *BuildsGetTaskLogOp, opts ...grpc.CallOption) (*LogEntries, error) {
	out := new(LogEntries)
	err := grpc.Invoke(ctx, "/sourcegraph.Builds/GetTaskLog", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildsClient) DequeueNext(ctx context.Context, in *BuildsDequeueNextOp, opts ...grpc.CallOption) (*Build, error) {
	out := new(Build)
	err := grpc.Invoke(ctx, "/sourcegraph.Builds/DequeueNext", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Builds service

type BuildsServer interface {
	// Get fetches a build.
	Get(context.Context, *BuildSpec) (*Build, error)
	// GetRepoBuildInfo gets the best-match build for a specific repo revspec. It
	// returns additional information about the build, such as whether it is exactly
	// up-to-date with the revspec or a few commits behind the revspec. The opt param
	// controls what is returned in this case.
	GetRepoBuildInfo(context.Context, *BuildsGetRepoBuildInfoOp) (*RepoBuildInfo, error)
	// List builds.
	List(context.Context, *BuildListOptions) (*BuildList, error)
	// Create a new build. The build will run asynchronously (Create does not wait for
	// it to return. To monitor the build's status, use Get.)
	Create(context.Context, *BuildsCreateOp) (*Build, error)
	// Update updates information about a build and returns the build after the update
	// has been applied.
	Update(context.Context, *BuildsUpdateOp) (*Build, error)
	// ListBuildTasks lists the tasks associated with a build.
	ListBuildTasks(context.Context, *BuildsListBuildTasksOp) (*BuildTaskList, error)
	// CreateTasks creates tasks associated with a build and returns them with their
	// TID fields set.
	CreateTasks(context.Context, *BuildsCreateTasksOp) (*BuildTaskList, error)
	// UpdateTask updates a task associated with a build.
	UpdateTask(context.Context, *BuildsUpdateTaskOp) (*BuildTask, error)
	// GetLog gets log entries associated with a build.
	GetLog(context.Context, *BuildsGetLogOp) (*LogEntries, error)
	// GetTaskLog gets log entries associated with a task.
	GetTaskLog(context.Context, *BuildsGetTaskLogOp) (*LogEntries, error)
	// DequeueNext returns the next queued build and marks it as
	// having started (atomically). If there are no builds in the
	// queue, a NotFound error is returned.
	DequeueNext(context.Context, *BuildsDequeueNextOp) (*Build, error)
}

func RegisterBuildsServer(s *grpc.Server, srv BuildsServer) {
	s.RegisterService(&_Builds_serviceDesc, srv)
}

func _Builds_Get_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(BuildSpec)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(BuildsServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builds_GetRepoBuildInfo_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(BuildsGetRepoBuildInfoOp)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(BuildsServer).GetRepoBuildInfo(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builds_List_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(BuildListOptions)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(BuildsServer).List(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builds_Create_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(BuildsCreateOp)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(BuildsServer).Create(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builds_Update_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(BuildsUpdateOp)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(BuildsServer).Update(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builds_ListBuildTasks_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(BuildsListBuildTasksOp)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(BuildsServer).ListBuildTasks(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builds_CreateTasks_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(BuildsCreateTasksOp)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(BuildsServer).CreateTasks(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builds_UpdateTask_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(BuildsUpdateTaskOp)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(BuildsServer).UpdateTask(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builds_GetLog_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(BuildsGetLogOp)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(BuildsServer).GetLog(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builds_GetTaskLog_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(BuildsGetTaskLogOp)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(BuildsServer).GetTaskLog(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Builds_DequeueNext_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(BuildsDequeueNextOp)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(BuildsServer).DequeueNext(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Builds_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Builds",
	HandlerType: (*BuildsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Builds_Get_Handler,
		},
		{
			MethodName: "GetRepoBuildInfo",
			Handler:    _Builds_GetRepoBuildInfo_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Builds_List_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _Builds_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _Builds_Update_Handler,
		},
		{
			MethodName: "ListBuildTasks",
			Handler:    _Builds_ListBuildTasks_Handler,
		},
		{
			MethodName: "CreateTasks",
			Handler:    _Builds_CreateTasks_Handler,
		},
		{
			MethodName: "UpdateTask",
			Handler:    _Builds_UpdateTask_Handler,
		},
		{
			MethodName: "GetLog",
			Handler:    _Builds_GetLog_Handler,
		},
		{
			MethodName: "GetTaskLog",
			Handler:    _Builds_GetTaskLog_Handler,
		},
		{
			MethodName: "DequeueNext",
			Handler:    _Builds_DequeueNext_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Orgs service

type OrgsClient interface {
	// Get fetches an organization.
	Get(ctx context.Context, in *OrgSpec, opts ...grpc.CallOption) (*Org, error)
	// List lists organizations that a user is a member of.
	List(ctx context.Context, in *OrgsListOp, opts ...grpc.CallOption) (*OrgList, error)
	// ListMembers lists members of an organization.
	ListMembers(ctx context.Context, in *OrgsListMembersOp, opts ...grpc.CallOption) (*UserList, error)
}

type orgsClient struct {
	cc *grpc.ClientConn
}

func NewOrgsClient(cc *grpc.ClientConn) OrgsClient {
	return &orgsClient{cc}
}

func (c *orgsClient) Get(ctx context.Context, in *OrgSpec, opts ...grpc.CallOption) (*Org, error) {
	out := new(Org)
	err := grpc.Invoke(ctx, "/sourcegraph.Orgs/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orgsClient) List(ctx context.Context, in *OrgsListOp, opts ...grpc.CallOption) (*OrgList, error) {
	out := new(OrgList)
	err := grpc.Invoke(ctx, "/sourcegraph.Orgs/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *orgsClient) ListMembers(ctx context.Context, in *OrgsListMembersOp, opts ...grpc.CallOption) (*UserList, error) {
	out := new(UserList)
	err := grpc.Invoke(ctx, "/sourcegraph.Orgs/ListMembers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Orgs service

type OrgsServer interface {
	// Get fetches an organization.
	Get(context.Context, *OrgSpec) (*Org, error)
	// List lists organizations that a user is a member of.
	List(context.Context, *OrgsListOp) (*OrgList, error)
	// ListMembers lists members of an organization.
	ListMembers(context.Context, *OrgsListMembersOp) (*UserList, error)
}

func RegisterOrgsServer(s *grpc.Server, srv OrgsServer) {
	s.RegisterService(&_Orgs_serviceDesc, srv)
}

func _Orgs_Get_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(OrgSpec)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(OrgsServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Orgs_List_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(OrgsListOp)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(OrgsServer).List(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Orgs_ListMembers_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(OrgsListMembersOp)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(OrgsServer).ListMembers(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Orgs_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Orgs",
	HandlerType: (*OrgsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Orgs_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Orgs_List_Handler,
		},
		{
			MethodName: "ListMembers",
			Handler:    _Orgs_ListMembers_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for People service

type PeopleClient interface {
	// Get gets a person. If an email is provided and it resolves to a registered user,
	// information about that user is returned. Otherwise a transient person is created
	// and returned.
	Get(ctx context.Context, in *PersonSpec, opts ...grpc.CallOption) (*Person, error)
}

type peopleClient struct {
	cc *grpc.ClientConn
}

func NewPeopleClient(cc *grpc.ClientConn) PeopleClient {
	return &peopleClient{cc}
}

func (c *peopleClient) Get(ctx context.Context, in *PersonSpec, opts ...grpc.CallOption) (*Person, error) {
	out := new(Person)
	err := grpc.Invoke(ctx, "/sourcegraph.People/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for People service

type PeopleServer interface {
	// Get gets a person. If an email is provided and it resolves to a registered user,
	// information about that user is returned. Otherwise a transient person is created
	// and returned.
	Get(context.Context, *PersonSpec) (*Person, error)
}

func RegisterPeopleServer(s *grpc.Server, srv PeopleServer) {
	s.RegisterService(&_People_serviceDesc, srv)
}

func _People_Get_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(PersonSpec)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(PeopleServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _People_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.People",
	HandlerType: (*PeopleServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _People_Get_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Accounts service

type AccountsClient interface {
	// Create creates a new user account.
	Create(ctx context.Context, in *NewAccount, opts ...grpc.CallOption) (*UserSpec, error)
	// RequestPasswordReset stores a password reset token in the database, to
	// later verify the authenticity of a user using CheckResetToken
	RequestPasswordReset(ctx context.Context, in *UserSpec, opts ...grpc.CallOption) (*User, error)
	// CheckResetToken verifies a password reset token is authentic and valid
	ResetPassword(ctx context.Context, in *NewPassword, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// Update profile of existing account.
	Update(ctx context.Context, in *User, opts ...grpc.CallOption) (*pbtypes1.Void, error)
}

type accountsClient struct {
	cc *grpc.ClientConn
}

func NewAccountsClient(cc *grpc.ClientConn) AccountsClient {
	return &accountsClient{cc}
}

func (c *accountsClient) Create(ctx context.Context, in *NewAccount, opts ...grpc.CallOption) (*UserSpec, error) {
	out := new(UserSpec)
	err := grpc.Invoke(ctx, "/sourcegraph.Accounts/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountsClient) RequestPasswordReset(ctx context.Context, in *UserSpec, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := grpc.Invoke(ctx, "/sourcegraph.Accounts/RequestPasswordReset", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountsClient) ResetPassword(ctx context.Context, in *NewPassword, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.Accounts/ResetPassword", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *accountsClient) Update(ctx context.Context, in *User, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.Accounts/Update", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Accounts service

type AccountsServer interface {
	// Create creates a new user account.
	Create(context.Context, *NewAccount) (*UserSpec, error)
	// RequestPasswordReset stores a password reset token in the database, to
	// later verify the authenticity of a user using CheckResetToken
	RequestPasswordReset(context.Context, *UserSpec) (*User, error)
	// CheckResetToken verifies a password reset token is authentic and valid
	ResetPassword(context.Context, *NewPassword) (*pbtypes1.Void, error)
	// Update profile of existing account.
	Update(context.Context, *User) (*pbtypes1.Void, error)
}

func RegisterAccountsServer(s *grpc.Server, srv AccountsServer) {
	s.RegisterService(&_Accounts_serviceDesc, srv)
}

func _Accounts_Create_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(NewAccount)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountsServer).Create(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Accounts_RequestPasswordReset_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(UserSpec)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountsServer).RequestPasswordReset(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Accounts_ResetPassword_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(NewPassword)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountsServer).ResetPassword(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Accounts_Update_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(User)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(AccountsServer).Update(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Accounts_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Accounts",
	HandlerType: (*AccountsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _Accounts_Create_Handler,
		},
		{
			MethodName: "RequestPasswordReset",
			Handler:    _Accounts_RequestPasswordReset_Handler,
		},
		{
			MethodName: "ResetPassword",
			Handler:    _Accounts_ResetPassword_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _Accounts_Update_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Users service

type UsersClient interface {
	// Get fetches a user.
	Get(ctx context.Context, in *UserSpec, opts ...grpc.CallOption) (*User, error)
	// ListEmails returns a list of a user's email addresses.
	ListEmails(ctx context.Context, in *UserSpec, opts ...grpc.CallOption) (*EmailAddrList, error)
	// List users.
	List(ctx context.Context, in *UsersListOptions, opts ...grpc.CallOption) (*UserList, error)
}

type usersClient struct {
	cc *grpc.ClientConn
}

func NewUsersClient(cc *grpc.ClientConn) UsersClient {
	return &usersClient{cc}
}

func (c *usersClient) Get(ctx context.Context, in *UserSpec, opts ...grpc.CallOption) (*User, error) {
	out := new(User)
	err := grpc.Invoke(ctx, "/sourcegraph.Users/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) ListEmails(ctx context.Context, in *UserSpec, opts ...grpc.CallOption) (*EmailAddrList, error) {
	out := new(EmailAddrList)
	err := grpc.Invoke(ctx, "/sourcegraph.Users/ListEmails", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *usersClient) List(ctx context.Context, in *UsersListOptions, opts ...grpc.CallOption) (*UserList, error) {
	out := new(UserList)
	err := grpc.Invoke(ctx, "/sourcegraph.Users/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Users service

type UsersServer interface {
	// Get fetches a user.
	Get(context.Context, *UserSpec) (*User, error)
	// ListEmails returns a list of a user's email addresses.
	ListEmails(context.Context, *UserSpec) (*EmailAddrList, error)
	// List users.
	List(context.Context, *UsersListOptions) (*UserList, error)
}

func RegisterUsersServer(s *grpc.Server, srv UsersServer) {
	s.RegisterService(&_Users_serviceDesc, srv)
}

func _Users_Get_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(UserSpec)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(UsersServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Users_ListEmails_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(UserSpec)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(UsersServer).ListEmails(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Users_List_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(UsersListOptions)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(UsersServer).List(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Users_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Users",
	HandlerType: (*UsersServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Users_Get_Handler,
		},
		{
			MethodName: "ListEmails",
			Handler:    _Users_ListEmails_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Users_List_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Auth service

type AuthClient interface {
	// GetAuthorizationCodeGrant gets an OAuth2 authorization code
	// grant from the server that can be traded in for an access token
	// by calling GetAccessToken. See
	// https://tools.ietf.org/html/rfc6749#section-4.1 for more
	// information.
	GetAuthorizationCode(ctx context.Context, in *AuthorizationCodeRequest, opts ...grpc.CallOption) (*AuthorizationCode, error)
	// GetAccessToken requests the server to issue an access token
	// using the credentials provided in the AccessTokenRequest.
	//
	// If this call is requesting an access token for a
	// client_credentials grant (i.e., the access token would identify
	// the client, not any specific user), then the request must not
	// be authenticated. If the call is requesting an access token to
	// identify a user, the request must be authenticated using the
	// client's credentials.
	//
	// If the credentials are invalid, grpc.PermissionDenied is
	// returned.
	GetAccessToken(ctx context.Context, in *AccessTokenRequest, opts ...grpc.CallOption) (*AccessTokenResponse, error)
	// Identify describes the currently authenticated user and/or
	// client (if any). It is akin to "whoami".
	Identify(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*AuthInfo, error)
}

type authClient struct {
	cc *grpc.ClientConn
}

func NewAuthClient(cc *grpc.ClientConn) AuthClient {
	return &authClient{cc}
}

func (c *authClient) GetAuthorizationCode(ctx context.Context, in *AuthorizationCodeRequest, opts ...grpc.CallOption) (*AuthorizationCode, error) {
	out := new(AuthorizationCode)
	err := grpc.Invoke(ctx, "/sourcegraph.Auth/GetAuthorizationCode", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authClient) GetAccessToken(ctx context.Context, in *AccessTokenRequest, opts ...grpc.CallOption) (*AccessTokenResponse, error) {
	out := new(AccessTokenResponse)
	err := grpc.Invoke(ctx, "/sourcegraph.Auth/GetAccessToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *authClient) Identify(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*AuthInfo, error) {
	out := new(AuthInfo)
	err := grpc.Invoke(ctx, "/sourcegraph.Auth/Identify", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Auth service

type AuthServer interface {
	// GetAuthorizationCodeGrant gets an OAuth2 authorization code
	// grant from the server that can be traded in for an access token
	// by calling GetAccessToken. See
	// https://tools.ietf.org/html/rfc6749#section-4.1 for more
	// information.
	GetAuthorizationCode(context.Context, *AuthorizationCodeRequest) (*AuthorizationCode, error)
	// GetAccessToken requests the server to issue an access token
	// using the credentials provided in the AccessTokenRequest.
	//
	// If this call is requesting an access token for a
	// client_credentials grant (i.e., the access token would identify
	// the client, not any specific user), then the request must not
	// be authenticated. If the call is requesting an access token to
	// identify a user, the request must be authenticated using the
	// client's credentials.
	//
	// If the credentials are invalid, grpc.PermissionDenied is
	// returned.
	GetAccessToken(context.Context, *AccessTokenRequest) (*AccessTokenResponse, error)
	// Identify describes the currently authenticated user and/or
	// client (if any). It is akin to "whoami".
	Identify(context.Context, *pbtypes1.Void) (*AuthInfo, error)
}

func RegisterAuthServer(s *grpc.Server, srv AuthServer) {
	s.RegisterService(&_Auth_serviceDesc, srv)
}

func _Auth_GetAuthorizationCode_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(AuthorizationCodeRequest)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(AuthServer).GetAuthorizationCode(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Auth_GetAccessToken_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(AccessTokenRequest)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(AuthServer).GetAccessToken(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Auth_Identify_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(pbtypes1.Void)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(AuthServer).Identify(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Auth_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Auth",
	HandlerType: (*AuthServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetAuthorizationCode",
			Handler:    _Auth_GetAuthorizationCode_Handler,
		},
		{
			MethodName: "GetAccessToken",
			Handler:    _Auth_GetAccessToken_Handler,
		},
		{
			MethodName: "Identify",
			Handler:    _Auth_Identify_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Defs service

type DefsClient interface {
	// Get fetches a def.
	Get(ctx context.Context, in *DefsGetOp, opts ...grpc.CallOption) (*Def, error)
	// List defs.
	List(ctx context.Context, in *DefListOptions, opts ...grpc.CallOption) (*DefList, error)
	// ListRefs lists references to def.
	ListRefs(ctx context.Context, in *DefsListRefsOp, opts ...grpc.CallOption) (*RefList, error)
	// ListExamples lists examples for def.
	ListExamples(ctx context.Context, in *DefsListExamplesOp, opts ...grpc.CallOption) (*ExampleList, error)
	// ListExamples lists people who committed parts of def's definition.
	ListAuthors(ctx context.Context, in *DefsListAuthorsOp, opts ...grpc.CallOption) (*DefAuthorList, error)
	// ListClients lists people who use def in their code.
	ListClients(ctx context.Context, in *DefsListClientsOp, opts ...grpc.CallOption) (*DefClientList, error)
}

type defsClient struct {
	cc *grpc.ClientConn
}

func NewDefsClient(cc *grpc.ClientConn) DefsClient {
	return &defsClient{cc}
}

func (c *defsClient) Get(ctx context.Context, in *DefsGetOp, opts ...grpc.CallOption) (*Def, error) {
	out := new(Def)
	err := grpc.Invoke(ctx, "/sourcegraph.Defs/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *defsClient) List(ctx context.Context, in *DefListOptions, opts ...grpc.CallOption) (*DefList, error) {
	out := new(DefList)
	err := grpc.Invoke(ctx, "/sourcegraph.Defs/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *defsClient) ListRefs(ctx context.Context, in *DefsListRefsOp, opts ...grpc.CallOption) (*RefList, error) {
	out := new(RefList)
	err := grpc.Invoke(ctx, "/sourcegraph.Defs/ListRefs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *defsClient) ListExamples(ctx context.Context, in *DefsListExamplesOp, opts ...grpc.CallOption) (*ExampleList, error) {
	out := new(ExampleList)
	err := grpc.Invoke(ctx, "/sourcegraph.Defs/ListExamples", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *defsClient) ListAuthors(ctx context.Context, in *DefsListAuthorsOp, opts ...grpc.CallOption) (*DefAuthorList, error) {
	out := new(DefAuthorList)
	err := grpc.Invoke(ctx, "/sourcegraph.Defs/ListAuthors", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *defsClient) ListClients(ctx context.Context, in *DefsListClientsOp, opts ...grpc.CallOption) (*DefClientList, error) {
	out := new(DefClientList)
	err := grpc.Invoke(ctx, "/sourcegraph.Defs/ListClients", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Defs service

type DefsServer interface {
	// Get fetches a def.
	Get(context.Context, *DefsGetOp) (*Def, error)
	// List defs.
	List(context.Context, *DefListOptions) (*DefList, error)
	// ListRefs lists references to def.
	ListRefs(context.Context, *DefsListRefsOp) (*RefList, error)
	// ListExamples lists examples for def.
	ListExamples(context.Context, *DefsListExamplesOp) (*ExampleList, error)
	// ListExamples lists people who committed parts of def's definition.
	ListAuthors(context.Context, *DefsListAuthorsOp) (*DefAuthorList, error)
	// ListClients lists people who use def in their code.
	ListClients(context.Context, *DefsListClientsOp) (*DefClientList, error)
}

func RegisterDefsServer(s *grpc.Server, srv DefsServer) {
	s.RegisterService(&_Defs_serviceDesc, srv)
}

func _Defs_Get_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(DefsGetOp)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(DefsServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Defs_List_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(DefListOptions)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(DefsServer).List(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Defs_ListRefs_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(DefsListRefsOp)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(DefsServer).ListRefs(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Defs_ListExamples_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(DefsListExamplesOp)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(DefsServer).ListExamples(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Defs_ListAuthors_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(DefsListAuthorsOp)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(DefsServer).ListAuthors(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Defs_ListClients_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(DefsListClientsOp)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(DefsServer).ListClients(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Defs_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Defs",
	HandlerType: (*DefsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Defs_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Defs_List_Handler,
		},
		{
			MethodName: "ListRefs",
			Handler:    _Defs_ListRefs_Handler,
		},
		{
			MethodName: "ListExamples",
			Handler:    _Defs_ListExamples_Handler,
		},
		{
			MethodName: "ListAuthors",
			Handler:    _Defs_ListAuthors_Handler,
		},
		{
			MethodName: "ListClients",
			Handler:    _Defs_ListClients_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Deltas service

type DeltasClient interface {
	// Get fetches a summary of a delta.
	Get(ctx context.Context, in *DeltaSpec, opts ...grpc.CallOption) (*Delta, error)
	// ListUnits lists units added/changed/deleted in a delta.
	ListUnits(ctx context.Context, in *DeltasListUnitsOp, opts ...grpc.CallOption) (*UnitDeltaList, error)
	// ListDefs lists definitions added/changed/deleted in a delta.
	ListDefs(ctx context.Context, in *DeltasListDefsOp, opts ...grpc.CallOption) (*DeltaDefs, error)
	// ListFiles fetches the file diff for a delta.
	ListFiles(ctx context.Context, in *DeltasListFilesOp, opts ...grpc.CallOption) (*DeltaFiles, error)
	// ListAffectedAuthors lists authors whose code is added/deleted/changed in a
	// delta.
	ListAffectedAuthors(ctx context.Context, in *DeltasListAffectedAuthorsOp, opts ...grpc.CallOption) (*DeltaAffectedPersonList, error)
	// ListAffectedClients lists clients whose code is affected by a delta.
	ListAffectedClients(ctx context.Context, in *DeltasListAffectedClientsOp, opts ...grpc.CallOption) (*DeltaAffectedPersonList, error)
}

type deltasClient struct {
	cc *grpc.ClientConn
}

func NewDeltasClient(cc *grpc.ClientConn) DeltasClient {
	return &deltasClient{cc}
}

func (c *deltasClient) Get(ctx context.Context, in *DeltaSpec, opts ...grpc.CallOption) (*Delta, error) {
	out := new(Delta)
	err := grpc.Invoke(ctx, "/sourcegraph.Deltas/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deltasClient) ListUnits(ctx context.Context, in *DeltasListUnitsOp, opts ...grpc.CallOption) (*UnitDeltaList, error) {
	out := new(UnitDeltaList)
	err := grpc.Invoke(ctx, "/sourcegraph.Deltas/ListUnits", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deltasClient) ListDefs(ctx context.Context, in *DeltasListDefsOp, opts ...grpc.CallOption) (*DeltaDefs, error) {
	out := new(DeltaDefs)
	err := grpc.Invoke(ctx, "/sourcegraph.Deltas/ListDefs", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deltasClient) ListFiles(ctx context.Context, in *DeltasListFilesOp, opts ...grpc.CallOption) (*DeltaFiles, error) {
	out := new(DeltaFiles)
	err := grpc.Invoke(ctx, "/sourcegraph.Deltas/ListFiles", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deltasClient) ListAffectedAuthors(ctx context.Context, in *DeltasListAffectedAuthorsOp, opts ...grpc.CallOption) (*DeltaAffectedPersonList, error) {
	out := new(DeltaAffectedPersonList)
	err := grpc.Invoke(ctx, "/sourcegraph.Deltas/ListAffectedAuthors", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *deltasClient) ListAffectedClients(ctx context.Context, in *DeltasListAffectedClientsOp, opts ...grpc.CallOption) (*DeltaAffectedPersonList, error) {
	out := new(DeltaAffectedPersonList)
	err := grpc.Invoke(ctx, "/sourcegraph.Deltas/ListAffectedClients", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Deltas service

type DeltasServer interface {
	// Get fetches a summary of a delta.
	Get(context.Context, *DeltaSpec) (*Delta, error)
	// ListUnits lists units added/changed/deleted in a delta.
	ListUnits(context.Context, *DeltasListUnitsOp) (*UnitDeltaList, error)
	// ListDefs lists definitions added/changed/deleted in a delta.
	ListDefs(context.Context, *DeltasListDefsOp) (*DeltaDefs, error)
	// ListFiles fetches the file diff for a delta.
	ListFiles(context.Context, *DeltasListFilesOp) (*DeltaFiles, error)
	// ListAffectedAuthors lists authors whose code is added/deleted/changed in a
	// delta.
	ListAffectedAuthors(context.Context, *DeltasListAffectedAuthorsOp) (*DeltaAffectedPersonList, error)
	// ListAffectedClients lists clients whose code is affected by a delta.
	ListAffectedClients(context.Context, *DeltasListAffectedClientsOp) (*DeltaAffectedPersonList, error)
}

func RegisterDeltasServer(s *grpc.Server, srv DeltasServer) {
	s.RegisterService(&_Deltas_serviceDesc, srv)
}

func _Deltas_Get_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(DeltaSpec)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(DeltasServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Deltas_ListUnits_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(DeltasListUnitsOp)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(DeltasServer).ListUnits(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Deltas_ListDefs_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(DeltasListDefsOp)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(DeltasServer).ListDefs(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Deltas_ListFiles_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(DeltasListFilesOp)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(DeltasServer).ListFiles(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Deltas_ListAffectedAuthors_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(DeltasListAffectedAuthorsOp)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(DeltasServer).ListAffectedAuthors(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Deltas_ListAffectedClients_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(DeltasListAffectedClientsOp)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(DeltasServer).ListAffectedClients(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Deltas_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Deltas",
	HandlerType: (*DeltasServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Deltas_Get_Handler,
		},
		{
			MethodName: "ListUnits",
			Handler:    _Deltas_ListUnits_Handler,
		},
		{
			MethodName: "ListDefs",
			Handler:    _Deltas_ListDefs_Handler,
		},
		{
			MethodName: "ListFiles",
			Handler:    _Deltas_ListFiles_Handler,
		},
		{
			MethodName: "ListAffectedAuthors",
			Handler:    _Deltas_ListAffectedAuthors_Handler,
		},
		{
			MethodName: "ListAffectedClients",
			Handler:    _Deltas_ListAffectedClients_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Markdown service

type MarkdownClient interface {
	Render(ctx context.Context, in *MarkdownRenderOp, opts ...grpc.CallOption) (*MarkdownData, error)
}

type markdownClient struct {
	cc *grpc.ClientConn
}

func NewMarkdownClient(cc *grpc.ClientConn) MarkdownClient {
	return &markdownClient{cc}
}

func (c *markdownClient) Render(ctx context.Context, in *MarkdownRenderOp, opts ...grpc.CallOption) (*MarkdownData, error) {
	out := new(MarkdownData)
	err := grpc.Invoke(ctx, "/sourcegraph.Markdown/Render", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Markdown service

type MarkdownServer interface {
	Render(context.Context, *MarkdownRenderOp) (*MarkdownData, error)
}

func RegisterMarkdownServer(s *grpc.Server, srv MarkdownServer) {
	s.RegisterService(&_Markdown_serviceDesc, srv)
}

func _Markdown_Render_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(MarkdownRenderOp)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(MarkdownServer).Render(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Markdown_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Markdown",
	HandlerType: (*MarkdownServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Render",
			Handler:    _Markdown_Render_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for RepoTree service

type RepoTreeClient interface {
	Get(ctx context.Context, in *RepoTreeGetOp, opts ...grpc.CallOption) (*TreeEntry, error)
	Search(ctx context.Context, in *RepoTreeSearchOp, opts ...grpc.CallOption) (*VCSSearchResultList, error)
}

type repoTreeClient struct {
	cc *grpc.ClientConn
}

func NewRepoTreeClient(cc *grpc.ClientConn) RepoTreeClient {
	return &repoTreeClient{cc}
}

func (c *repoTreeClient) Get(ctx context.Context, in *RepoTreeGetOp, opts ...grpc.CallOption) (*TreeEntry, error) {
	out := new(TreeEntry)
	err := grpc.Invoke(ctx, "/sourcegraph.RepoTree/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repoTreeClient) Search(ctx context.Context, in *RepoTreeSearchOp, opts ...grpc.CallOption) (*VCSSearchResultList, error) {
	out := new(VCSSearchResultList)
	err := grpc.Invoke(ctx, "/sourcegraph.RepoTree/Search", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for RepoTree service

type RepoTreeServer interface {
	Get(context.Context, *RepoTreeGetOp) (*TreeEntry, error)
	Search(context.Context, *RepoTreeSearchOp) (*VCSSearchResultList, error)
}

func RegisterRepoTreeServer(s *grpc.Server, srv RepoTreeServer) {
	s.RegisterService(&_RepoTree_serviceDesc, srv)
}

func _RepoTree_Get_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(RepoTreeGetOp)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(RepoTreeServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RepoTree_Search_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(RepoTreeSearchOp)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(RepoTreeServer).Search(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _RepoTree_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.RepoTree",
	HandlerType: (*RepoTreeServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _RepoTree_Get_Handler,
		},
		{
			MethodName: "Search",
			Handler:    _RepoTree_Search_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Search service

type SearchClient interface {
	// Search searches the full index.
	Search(ctx context.Context, in *SearchOptions, opts ...grpc.CallOption) (*SearchResults, error)
	// Complete completes the token at the RawQuery's InsertionPoint.
	Complete(ctx context.Context, in *RawQuery, opts ...grpc.CallOption) (*Completions, error)
	// Suggest suggests queries given an existing query. It can be called with an empty
	// query to get example queries that pertain to the current user's repositories,
	// orgs, etc.
	Suggest(ctx context.Context, in *RawQuery, opts ...grpc.CallOption) (*SuggestionList, error)
}

type searchClient struct {
	cc *grpc.ClientConn
}

func NewSearchClient(cc *grpc.ClientConn) SearchClient {
	return &searchClient{cc}
}

func (c *searchClient) Search(ctx context.Context, in *SearchOptions, opts ...grpc.CallOption) (*SearchResults, error) {
	out := new(SearchResults)
	err := grpc.Invoke(ctx, "/sourcegraph.Search/Search", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchClient) Complete(ctx context.Context, in *RawQuery, opts ...grpc.CallOption) (*Completions, error) {
	out := new(Completions)
	err := grpc.Invoke(ctx, "/sourcegraph.Search/Complete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *searchClient) Suggest(ctx context.Context, in *RawQuery, opts ...grpc.CallOption) (*SuggestionList, error) {
	out := new(SuggestionList)
	err := grpc.Invoke(ctx, "/sourcegraph.Search/Suggest", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Search service

type SearchServer interface {
	// Search searches the full index.
	Search(context.Context, *SearchOptions) (*SearchResults, error)
	// Complete completes the token at the RawQuery's InsertionPoint.
	Complete(context.Context, *RawQuery) (*Completions, error)
	// Suggest suggests queries given an existing query. It can be called with an empty
	// query to get example queries that pertain to the current user's repositories,
	// orgs, etc.
	Suggest(context.Context, *RawQuery) (*SuggestionList, error)
}

func RegisterSearchServer(s *grpc.Server, srv SearchServer) {
	s.RegisterService(&_Search_serviceDesc, srv)
}

func _Search_Search_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(SearchOptions)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(SearchServer).Search(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Search_Complete_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(RawQuery)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(SearchServer).Complete(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Search_Suggest_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(RawQuery)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(SearchServer).Suggest(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Search_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Search",
	HandlerType: (*SearchServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Search",
			Handler:    _Search_Search_Handler,
		},
		{
			MethodName: "Complete",
			Handler:    _Search_Complete_Handler,
		},
		{
			MethodName: "Suggest",
			Handler:    _Search_Suggest_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Units service

type UnitsClient interface {
	// Get fetches a unit.
	Get(ctx context.Context, in *UnitSpec, opts ...grpc.CallOption) (*unit.RepoSourceUnit, error)
	// List units.
	List(ctx context.Context, in *UnitListOptions, opts ...grpc.CallOption) (*RepoSourceUnitList, error)
}

type unitsClient struct {
	cc *grpc.ClientConn
}

func NewUnitsClient(cc *grpc.ClientConn) UnitsClient {
	return &unitsClient{cc}
}

func (c *unitsClient) Get(ctx context.Context, in *UnitSpec, opts ...grpc.CallOption) (*unit.RepoSourceUnit, error) {
	out := new(unit.RepoSourceUnit)
	err := grpc.Invoke(ctx, "/sourcegraph.Units/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *unitsClient) List(ctx context.Context, in *UnitListOptions, opts ...grpc.CallOption) (*RepoSourceUnitList, error) {
	out := new(RepoSourceUnitList)
	err := grpc.Invoke(ctx, "/sourcegraph.Units/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Units service

type UnitsServer interface {
	// Get fetches a unit.
	Get(context.Context, *UnitSpec) (*unit.RepoSourceUnit, error)
	// List units.
	List(context.Context, *UnitListOptions) (*RepoSourceUnitList, error)
}

func RegisterUnitsServer(s *grpc.Server, srv UnitsServer) {
	s.RegisterService(&_Units_serviceDesc, srv)
}

func _Units_Get_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(UnitSpec)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(UnitsServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Units_List_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(UnitListOptions)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(UnitsServer).List(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Units_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Units",
	HandlerType: (*UnitsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Units_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Units_List_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for Meta service

type MetaClient interface {
	// Status returns status information from the server's point of
	// view.
	Status(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*ServerStatus, error)
	// Config returns the server's configuration.
	Config(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*ServerConfig, error)
}

type metaClient struct {
	cc *grpc.ClientConn
}

func NewMetaClient(cc *grpc.ClientConn) MetaClient {
	return &metaClient{cc}
}

func (c *metaClient) Status(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*ServerStatus, error) {
	out := new(ServerStatus)
	err := grpc.Invoke(ctx, "/sourcegraph.Meta/Status", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *metaClient) Config(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*ServerConfig, error) {
	out := new(ServerConfig)
	err := grpc.Invoke(ctx, "/sourcegraph.Meta/Config", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Meta service

type MetaServer interface {
	// Status returns status information from the server's point of
	// view.
	Status(context.Context, *pbtypes1.Void) (*ServerStatus, error)
	// Config returns the server's configuration.
	Config(context.Context, *pbtypes1.Void) (*ServerConfig, error)
}

func RegisterMetaServer(s *grpc.Server, srv MetaServer) {
	s.RegisterService(&_Meta_serviceDesc, srv)
}

func _Meta_Status_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(pbtypes1.Void)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(MetaServer).Status(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Meta_Config_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(pbtypes1.Void)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(MetaServer).Config(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Meta_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.Meta",
	HandlerType: (*MetaServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Status",
			Handler:    _Meta_Status_Handler,
		},
		{
			MethodName: "Config",
			Handler:    _Meta_Config_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for RegisteredClients service

type RegisteredClientsClient interface {
	// Get retrieves an API client's record given its client ID.
	Get(ctx context.Context, in *RegisteredClientSpec, opts ...grpc.CallOption) (*RegisteredClient, error)
	// GetCurrent is equivalent to a call to Get with the client ID of
	// the currently authenticated client.
	GetCurrent(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*RegisteredClient, error)
	// Create registers an API client.
	Create(ctx context.Context, in *RegisteredClient, opts ...grpc.CallOption) (*RegisteredClient, error)
	// Update modifies an API client's record. The RegisteredClient
	// arg's ID must be set (to specify which client to update). Its
	// Secret field is ignored (the secret may not be updated after
	// creation).
	Update(ctx context.Context, in *RegisteredClient, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// Delete removes an API client. Immediately after deletion, it
	// may no longer be used.
	Delete(ctx context.Context, in *RegisteredClientSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error)
	// List enumerates API clients according to the options.
	List(ctx context.Context, in *RegisteredClientListOptions, opts ...grpc.CallOption) (*RegisteredClientList, error)
}

type registeredClientsClient struct {
	cc *grpc.ClientConn
}

func NewRegisteredClientsClient(cc *grpc.ClientConn) RegisteredClientsClient {
	return &registeredClientsClient{cc}
}

func (c *registeredClientsClient) Get(ctx context.Context, in *RegisteredClientSpec, opts ...grpc.CallOption) (*RegisteredClient, error) {
	out := new(RegisteredClient)
	err := grpc.Invoke(ctx, "/sourcegraph.RegisteredClients/Get", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registeredClientsClient) GetCurrent(ctx context.Context, in *pbtypes1.Void, opts ...grpc.CallOption) (*RegisteredClient, error) {
	out := new(RegisteredClient)
	err := grpc.Invoke(ctx, "/sourcegraph.RegisteredClients/GetCurrent", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registeredClientsClient) Create(ctx context.Context, in *RegisteredClient, opts ...grpc.CallOption) (*RegisteredClient, error) {
	out := new(RegisteredClient)
	err := grpc.Invoke(ctx, "/sourcegraph.RegisteredClients/Create", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registeredClientsClient) Update(ctx context.Context, in *RegisteredClient, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.RegisteredClients/Update", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registeredClientsClient) Delete(ctx context.Context, in *RegisteredClientSpec, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.RegisteredClients/Delete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *registeredClientsClient) List(ctx context.Context, in *RegisteredClientListOptions, opts ...grpc.CallOption) (*RegisteredClientList, error) {
	out := new(RegisteredClientList)
	err := grpc.Invoke(ctx, "/sourcegraph.RegisteredClients/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for RegisteredClients service

type RegisteredClientsServer interface {
	// Get retrieves an API client's record given its client ID.
	Get(context.Context, *RegisteredClientSpec) (*RegisteredClient, error)
	// GetCurrent is equivalent to a call to Get with the client ID of
	// the currently authenticated client.
	GetCurrent(context.Context, *pbtypes1.Void) (*RegisteredClient, error)
	// Create registers an API client.
	Create(context.Context, *RegisteredClient) (*RegisteredClient, error)
	// Update modifies an API client's record. The RegisteredClient
	// arg's ID must be set (to specify which client to update). Its
	// Secret field is ignored (the secret may not be updated after
	// creation).
	Update(context.Context, *RegisteredClient) (*pbtypes1.Void, error)
	// Delete removes an API client. Immediately after deletion, it
	// may no longer be used.
	Delete(context.Context, *RegisteredClientSpec) (*pbtypes1.Void, error)
	// List enumerates API clients according to the options.
	List(context.Context, *RegisteredClientListOptions) (*RegisteredClientList, error)
}

func RegisterRegisteredClientsServer(s *grpc.Server, srv RegisteredClientsServer) {
	s.RegisterService(&_RegisteredClients_serviceDesc, srv)
}

func _RegisteredClients_Get_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(RegisteredClientSpec)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(RegisteredClientsServer).Get(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RegisteredClients_GetCurrent_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(pbtypes1.Void)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(RegisteredClientsServer).GetCurrent(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RegisteredClients_Create_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(RegisteredClient)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(RegisteredClientsServer).Create(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RegisteredClients_Update_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(RegisteredClient)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(RegisteredClientsServer).Update(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RegisteredClients_Delete_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(RegisteredClientSpec)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(RegisteredClientsServer).Delete(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _RegisteredClients_List_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(RegisteredClientListOptions)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(RegisteredClientsServer).List(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _RegisteredClients_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.RegisteredClients",
	HandlerType: (*RegisteredClientsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _RegisteredClients_Get_Handler,
		},
		{
			MethodName: "GetCurrent",
			Handler:    _RegisteredClients_GetCurrent_Handler,
		},
		{
			MethodName: "Create",
			Handler:    _RegisteredClients_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _RegisteredClients_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _RegisteredClients_Delete_Handler,
		},
		{
			MethodName: "List",
			Handler:    _RegisteredClients_List_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

// Client API for GraphUplink service

type GraphUplinkClient interface {
	// Push sends the latest metrics to the upstream instance
	Push(ctx context.Context, in *MetricsSnapshot, opts ...grpc.CallOption) (*pbtypes1.Void, error)
}

type graphUplinkClient struct {
	cc *grpc.ClientConn
}

func NewGraphUplinkClient(cc *grpc.ClientConn) GraphUplinkClient {
	return &graphUplinkClient{cc}
}

func (c *graphUplinkClient) Push(ctx context.Context, in *MetricsSnapshot, opts ...grpc.CallOption) (*pbtypes1.Void, error) {
	out := new(pbtypes1.Void)
	err := grpc.Invoke(ctx, "/sourcegraph.GraphUplink/Push", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for GraphUplink service

type GraphUplinkServer interface {
	// Push sends the latest metrics to the upstream instance
	Push(context.Context, *MetricsSnapshot) (*pbtypes1.Void, error)
}

func RegisterGraphUplinkServer(s *grpc.Server, srv GraphUplinkServer) {
	s.RegisterService(&_GraphUplink_serviceDesc, srv)
}

func _GraphUplink_Push_Handler(srv interface{}, ctx context.Context, codec grpc.Codec, buf []byte) (interface{}, error) {
	in := new(MetricsSnapshot)
	if err := codec.Unmarshal(buf, in); err != nil {
		return nil, err
	}
	out, err := srv.(GraphUplinkServer).Push(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _GraphUplink_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sourcegraph.GraphUplink",
	HandlerType: (*GraphUplinkServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Push",
			Handler:    _GraphUplink_Push_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}
